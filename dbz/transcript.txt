- In this lesson, we look at the basics of working in the Python programming environment. This includes starting and stopping the interpretor, using the interactive console, editing and running programs, and how to turn simple programs into useful scripts. Getting help and some basic debugging tips are also described.


- In this first part, I'm going to look at how to start and stop the python interpreter and work in the environment. And first things first, python is normally a command that you would run at the terminal or a console. So if you're on a unix machine, you would type a command such as python three, and that would bring up the python interpreter. Once the interpreter is up, it's something that you can actually experiment with. You can start typing in commands and this actually turns out to be one of the most useful parts of python is this interactive environment where you can experiment with it and get immediate gratification on things that you want to try. A few things about this environment, just to get it out of the way first. The triple greater than is python asking you to type a new command. So if you see that, it's asking you to do something. So you type something in and see the result. If you type something and you get triple dots showing up like in that for statement, it means that python wants you to continue typing what you just did. So it's actually waiting for me to continue with what I just started, so I might type another command in there. Again, I would get triple dots, it's waiting for me to type some more. In order to get that code to run, you just have to hit return. So if you enter a blank line, you'll see the code run at that point. Again, this interactive mode is a great way to kind of interact with the language, use it as a calculator and experiment. A few other things about the interactive mode, if you want to save the result of something that you're working on, assign it to a name. So you could say something like A is equal to 42 times ten, and that A becomes something that you can use in later calculations. So I could say that B is equal to five times A. Another thing about saving results, if you happen to be using the interpreter and let's say you didn't save the result that you just calculated, you can get to it by using the underscore variable. So underscore holds the result of the last thing that you did, that's actually a feature that's only available in the interactive mode. But it can be useful if you're using python to do calculations, using it as your desktop calculator, for instance. If you need to cycle between previous commands, usually up and down arrow will work. So if you hit up arrow, you'll see it kind of cycling through previous lines. Down arrow will go in the opposite direction. Another thing that is available is there is online help, so if you saw me type something and you want more information about it, like help about the print statement or print function you could say help print. And you will get a little bit of help information. To be honest, that help it may or may not be useful. I mean the official help for python would be found on the website. So if you do need to get information about the python language, you would probably want to go to python.org. And then there is a documentation site for that. Probably the most useful part of that might be the library reference, so you can get the library reference and what is says and keep this under your pillow, it's not lying about that. So that would give you information about everything that's kind of part of the language and you can go there and get more information about things that you see. In terms of this course, I'm hoping that you don't actually have to rely on the help too much. But that is something that is available. Now to get out of the python interpreter, you can type quit or you can hit control D and that will take you out of the interpreter. So if you're just experimenting and you need to start and stop, again you type python three to start, you either type quit or control D to get out. The final thing I wanted to talk about for getting started is just the problem of making a file. So let's say you wanted to make a file that you can run over and over again. To do that, you need to edit a program using your favorite editor, I use emacs but there are many options available. So what you could do is make a file, like hello.py and what you're going to do in here is put any python statement that I've used so far into this file. And I will save this as a program, hello.py on my machine. In order to run that what you do is you just give this to the python interpreter. So I'm going split screen here, the top is my program that I'm going to run down here I have the unix shell. If I want to run python on that program, I would give that to the python interpreter, so I would say python three hello.py and you would see the program run. So this is a common way of making files, editing them, having them run in the interpreter.

- The Python interactive interpreter is actually one of the most useful features of the language, if you ask me, and I, I tend to use it all the time for experimenting and then trying things out. And to motivate that I thought I would do a more interesting example than just Hello World. Essentially the example involves my office. So my office in Chicago is located on Clark Street, right next to a cta bus stop. One of the things that you'll find on these bus stops is they have information where you can text, like a certain code in, and find out when the next bus is going to arrive. And so, what I thought I would do is an example of me getting that information from Python, so I can find out when to hop the bus and head down to Wrigley Field, maybe catch a Cubs game. So to do that, what I've got, got the bus stop up above and I'm gonna fire up Python down below and I'm gonna interactively find out how long I'm gonna have to wait at this bus stop for something to show up. I'll talk about some of the features that I'm using as I type. The first thing that I'm gonna do is I'm gonna import a library. So Python comes with the large library of modules for doing different things. This library that I've imported is something that can let me go out and fetch web pages. It let's me make http request out on the web and I'm gonna go to a site that the city of Chicago runs for tracking buses. I'm gonna pull down the stop prediction from that. Don't ask how I got this URL, although you can find out online if you need to. What I'm gonna do is essentially punch in some numbers on here, so I'm gonna make a request saying I want information about stop 14787. That's this little code down in the bottom or to cta bus, and then the route is the bus route number on that. So I'm gonna make a request and if that works, I'm going to read some data there, and I'll get something that looks like that. Now that looks a little bit cryptic, but what I've got is a fragment of xml. Okay, comes back, identifies itself as xml and embedded in that xml there are stop estimations, there's these little pt elements that I could try to extract out of there, and so to do that, I'm going to load another module from Python. This statement here is another way of importing a library and what I'm going to do is turn that data that I just read into an xml document of some sort. Don't worry about the details so much right now. What I'm gonna with that is I'm gonna write a little query, where I'll ask to go find all the pt elements in that data and then print out what they're texting. So just doing the interactive Python interpreter, I have found out I will have to wait seven minutes at this bus stop to go down the street and then if I miss that bus I'll get another one in 10 minutes, and then in 20 minutes. This is the kind of cool style that you can do with this interactive mode of Python. I mean, again, you can try things out, you can experiment with it, it's like instant gratification. This is so much more compelling than just printing Hello World if you ask me. Now because that might be a useful thing to do, I thought I would take that code and put it into a file. So, you know, typing at the interactive prop, that's great, but probably what you wanna do is make a file that will do that instead. So again, if you wanna make a program that you can run over and over again, you fire up your editor and you put those same statements into a file. So I'm going to again do the import statement that's loading a library. I'll make that request to go fetch the bus information here. Okay, again, this asking for as stop prediction from the city here. And I have to give the route number and stop ID. Okay, so I'm gonna make this request, we'll get the data. Again, typing the command's pretty much the same that I did in the interactive interpreter down below, and then I'm gonna go find all of the pt element. Okay, so now I've got a little program nextbus.py. I now have a program that whenever I want to find out when the bus comes by my office, I can run python3 on that nextbus and it will tell me. Wow, okay, I've made a mistake there. Very common thing to make a mistake. What I forgot in the code is to do urlopen. We'll talk more about Traceback messages in a later lesson, but that's what happened there. So let's run the program. Now I have a different mistake. I have a typo in my URL. That error down below it says 404, that's an http error that you get if you to a non existing web page. So let's try it. Okay, so now I have to wait five minutes for the bus. This is the kind of thing you would do to get started. That interactive mode, very useful for experimentation. Once you've experimented a little bit, put it into a file and then you can run your file over and over again.

- In the last part we wrote a script that found out when the next bus was gonna come by my office in Chicago, and just to refresh your memory on that, the code that I'm showing here is that script, and then if I ran that, what it would do is give me the stop estimation, sort of saying when the next bus is coming. So, it actually tells me that one is approaching right now, that I have to wait nine minutes and 19 minutes. One of the problems with this program is that it is hardwired specifically to my office in Chicago, I mean it only works for that one bus stop. That is the kinda thing that you might wanna generalize. A lot of people use Python to write little scripts, little utility scripts and so forth, and they wanna be able to use it on different data. So what I'm gonna do here is modify this program to read the stop number and route number from the command line or from the UNIX command line, and it's useful just to see how that works. So, in order to do that there's a module called sys that is part of Python and inside that module there's a variable called sys.argv that has the command line options in there. I guess to start, let me just print out what they are. Command options, and I'll print sys.argv, and then I'm gonna make the program quit. The statement that I've got here by the way, this is how you make Python just stop. So if you wanted a program to terminate earlier, raise a system exit. And so if I do that, what's going to happen is the program will let me pass different arguments on the command line. Like I could say python next bus, you know 22 14787, and what the sys.argv is, is it actually holds these things that I passed on the command line. So here's what you can do to get that information out. I'm gonna put a little check in here that just checks to see whether the number of command line arguments is not equal to three, and if it's not I'll print a little usage message to the user saying hey you have to use next bus, and then give it a route number and a stop ID. And then if it does look okay, what I'm going to do is pull out information from the argument. So it turns out the route number is the first argument, the zero argument is the name of the program, so one is 22, and then I'll get the stop ID out of argument two. And then instead of having those numbers hardwired into this URL, what I'm going to do is plug them in doing a little bit of string formatting. So I'm gonna plug in the route number and the stop ID into that format method, and then what's going to happen now is I have this program working as a script, I can type next bus, I can put in a route and stop ID and it will give me information for that combination. What it would do is generalize the code, where I can put in different stop IDs, I can go to different bus stops in Chicago. You know, if I wanted to find out like when the route 6 bus would come by stop 5037, I could punch in that. So in some sense I've made the code more general. Again, this is something that's very common in running python, a lot of people use it to write little utility scripts and they wanna take input. This is an easy way to do that. The other thing I wanted to just show at this point, is sometimes people wanna have a script where it will run without having to type the python command first. You know, in all of these examples I have to type python and then the name of the program. If you wanna get rid of that, one of the things that you can do, at least on a UNIX machine, is use what's known as a pound bang trick, you make an executable line at the start, say userbin environment, python three, and then you can make that program executable, and then that will become something that you can just run all on its own, you don't have to use the python interpreter to explicitly run that. So this is some common things when writing scripts. It's useful to know when getting started. This is often how people start using python is in this way.

- Let's talk about some basic techniques for debugging Python programs. As you start to write code, you're gonna make mistakes. And figuring out how to recover from those mistakes is a skill that will take some time to develop. So, to do that, again, I have this program that we wrote in the last part, for finding out when a next bus was going to come by my office. And normally when that program runs, you type something like "python3 nextbus 22 14787" and you get a result back. If there is a mistake in the program, what is going to happen is the program is going to crash. So, just to illustrate that, let me make a mistake in the program. Let me change a name in the program and run it again. If I run that with a mistake in it, Python will crash, and it will generate a traceback message. Reading these traceback messages, the most essential part of it is that the very last line is actually what is wrong with your program. So if you are looking at the error message and you are saying, "Hmm, I wonder why that's not working," the very last line is what's wrong. Okay, it comes back and says, "Attribute Error, "there is no attribute txt." And then right above that it's showing a line of code from my program. For something like that it might be as simple as just a typo in a name. That's the mistake that I made as I changed the name. You can fix it by fixing the program. You might have to consult the help or the documentation to do that, but it's like a simple programming mistake that is taking place there. Other kinds of errors are maybe a little bit more daunting. For example, let's say I went to this program and I made a mistake in the URL. Let's say I made a typo in that and then I ran the program with that mistake. What's going to happen here is you're going to get a much larger error message. I mean, if you look at the error message, it goes on for line, after line, after line. It's very easy to look at that and become very intimidated. For something like that you have to carefully look at the message that's being generated. First of all, the last line, again, this is what is wrong with the program. It comes back and it says, "HTTP Error 404: Not Found." And then what it's doing is it's showing a whole bunch of code in libraries that is not my program. Okay, these lines of code that it's showing, these are not part of my nextbus program. And the way to maybe interpret that is that maybe I've given some bad input to a function. I gave it like bad input, it went through a whole chain of operations and then crashed. And so for something like that I have to look at my program and look at the inputs to maybe the urlopen function. The fact that this is reporting a 404 is telling me that the URL is bad, it's going to a non-existent URL. So that should give me some clue about how to fix that, by changing it back and get the program to work again. Now some other programming techniques that I think are worth knowing about, let's go back to the original crash, here we had a name problem like that. One thing that is actually very useful to do is to run Python with the -i option. You can say, "Well, what does that do?" What that does is it will run the program and then drop you into Python's interactive prompt afterwords. This can be a very useful way to kind of poke around and look at what is happening. Like I can look at the data that came back, I can look at this document that's in the program, I can maybe try different experiments with it to see maybe I screwed something up somewhere. I mean, essentially what can happen is your program can crash, and then you can come back afterwords and poke around at it. That's one useful technique for debugging, it's to know about the Python -i option. Some other techniques for debugging, obviously, you can do print statements, you know, like printing the text out here, that works fine for debugging as well. I mean, I can put a print statement anywhere I want and see what is happening here. Like if I wanted to see the response of that request, I could put a print statement in there and just view what happens. Okay, so now it's showing me the response. Another thing that may be useful is the Python debugger. Let me go back to my original error there. If your program crashes and you are using this -i option, one thing that you could do is load the debugger. So there is this module pdb that you can load, and if you do pdb.pm, which is short for post-mortem, it's kind of a weird thing to type, it will take you into the code, show you the line of code where it's failed, and then you can do poking around. You can do print statements from here, you can get program listings to sort of find out kind of surrounding context and so forth. Another thing that I'll mention, since it involves the debugger, sometimes you will see people launching the debugger in the code itself, by putting this statement in here. I'll just put a comment next to it, "Launch the debugger." That is kind of like a manual break point. I wouldn't say it comes up super common, but if you have a large program and you're just completely lost about what is happening, you might put that in the program. And what will happen is when you run the program, it will hit that point and then go straight into the debugger. At that point you can poke around, you can maybe single-step through the code if you want, you can make it, you know, run afterwords and so forth. So, these are all tools useful to know about the debugging. As you start to write larger programs, it'll be useful to be able to do that.

- In this lesson, we look at Python's execution model and describe the statements related to variables, expressions, and simple control flow. We also look at using Python to perform simple mathematical calculations, making formatted output, and writing to a file.

2.1 Project: Mortgage Calculator

- To talk more about how Python works, I thought we'd do a little project figuring out how long it's gonna take to pay off a mortgage. Essentially we're gonna use Python as a calculator and talk about some of its basic statements for control flow and calculation. To start this off, what I'm doing is making a program called mortgage.py, and the very first thing that I thought I would talk about, is just the execution of Python statements. Python really does come out of the world of scripting languages, and the way that it executes your program is it starts at the top of the program and goes line by line, executing each statement. The things I'm typing here are comments. I'm writing a program, mortgage.py, you know, find out how long to pay off a mortgage. A comment is something that starts with a pound sign, just goes to the end of the line. (typing) Okay, so that's what I'm gonna start the program with. What I'm gonna do next, are define some variables. So if you wanna store a value, what you do is you just assign a name to a value, like principal is equal to 500,000 or payment is equal to 2684.11, rate is 0.05. What you're doing is you're making variable declarations by doing this. A few things that are of interest, if you come from another programming language, Python does not require you to declare data types. So if you're used to saying things like float payment, you don't do that in Python. Essentially a variable is a name for a value. The type, if you wanna think about it, comes from the value that's being assigned. The fact that this 2684 is a float, makes payment a float. Another thing that I'll mention is just the rules for variables. Variable names in Python have to start with either a letter or an underscore, and then consist of letters, underscores, or digits after that. So, for instance, I could put an underscore on the name of that variable and that's fine. I could put digits into the variable name and that's okay too. The main thing is you can't start a variable name with a digit. Python follows, really kinda the same conventions that a lot of other programming languages follow. So I've designed some variables to get started here. Now what I'm gonna do is start doing some calculations. And the way that this is going to work is I'm going to execute a while loop while the principal is greater than zero. While statement is one of Python's control flow structures, and what it's going to do is execute a block of statements as long as this condition is true. So as long as principal is greater than zero, it's going to execute statements. And in here, I'm going to do some math calculations. So let's figure out the interest on this thing. The interest will be the principal times the rate divided by 12. And then I'm gonna update the principal by adding in the interest, and then taking away whatever the payment is. And then I'll update a variable by adding in the payment here. OK, so I'm using Python as a little calculator. As far as doing math calculations, there's not really any big surprises in Python. It follows the same rules that you would find from a math class, as far as what the operators are, the order of operations, and so forth. So you can certainly use those in a Python program, and it will work the way you expect it to work. Another thing that you're seeing here just concerns the structure of this while statement itself. One thing that you might ask: what denotes the start and the end of this while loop? This is actually one of Python's more controversial features, but it's indentation. If you wanna know what the while loop is executing, it's executing all of the statements that are indented under it. So all of those statements that you see indented there will execute in the loop. The way that you terminate the loop, is you have a statement that is not indented. So, for instance, this print statement at the end, that ends the while loop because it's not indented under the while loop. Few things about that indentation feature, by the way, the only thing that Python cares about, is that you're consistent with your indentation. So the fact that it's indented four spaces, that doesn't really matter. I could indent two spaces if I wanted to, or I could indent six spaces. Again Python won't be bothered by that, as long as you're consistent with your indentation. If, for some reason, your code started to look ragged, like that, then it's not going to work. You'll get an error when you try to run your program. Just so you know, there is a standard for indentation. Usually programs are indented by four spaces, so if you define a block, you go in four spaces, and you use spaces instead of tabs, by the way. Turns out if you use the tab character in a python program, it just won't even run, you get a syntax error. So here's a simple program. Take a look at it, make sure that it looks reasonable here. Have some comments at the top, some variable definitions under that, a while loop to carry out a calculation. If I run this, (typing) It should come up, we'll see if it runs here. It comes up and says I paid 966,000 dollars, using Python as a calculator. Now, to extend this program, let's focus on the amount paid there. I'm, clearly, in the wrong line of work, it seems, you know, the fact that this mortgage is gonna cost almost a million dollars, and it's only a 500,000 dollar mortgage. One of the things that we, maybe, wanna do is find out whether we can reduce the amount by having, maybe, an extra payment of some kind. Maybe I'm gonna modify the program by having an extra payment of a thousand dollars. (typing) And then maybe I'll apply this over some time period. (typing) What I'm doing here, is maybe modifying the program to, kind of, play a scenario or something. Like if I were to pay an extra thousand dollars for the first 60 months, would that reduce the amount of the mortgage or not? So, what I'm doing here is introducing more variables into the program, and then maybe I'll modify this while loop to update those. So I'm gonna increment the month and then maybe I'll check to see whether the month is in this range, (typing) start and end month. To do that I'm using another control flow feature of Python which is the if statement. So this is how you do a conditional, you use if to check whether something is true or not. The body of the with is indented. Remember you always indent when you wanna denote a body of something. If I have that extra payment being applied, the total is going to be payment plus extra payment. And then if that's not true, maybe the total payment is just gonna be paid. So we've modified the program, have an if and else statement in there. Again if you've used another programming language, if and else in Python works exactly the same way it does in other programming languages. And then I'm gonna modify the program to incorporate that total payment. Okay, so instead of payment we're gonna update with total payment. So we've got a little modification to the code here, let's go ahead and run that, see if it makes any difference at all in our calculation. So we run that, tells us we now have to pay 824,000 dollars. Just to kinda know whether that's a good deal or not, we can fire up Python as a calculator, and maybe compute the difference. 966 minus 824, okay, is 141,000 dollars. And then we paid in 60,000 dollars with extra payments doing that. So looks like we maybe saved about 80,000 dollars. Definitely a good deal on my part. So as a little summary of what we've done here; this is the kind of code that you would typically write if you're just using Python for a lot of scripting tasks. There's not a whole lot to the language, per say, I mean you have comments, you have variables, you have while loops, you have if statements. You can kinda put that together and write larger programs doing that. So getting started is usually not a very hard thing in Python.

- The last part, we wrote a program that figured out how long it would take me to pay off a mortgage. I put up the code just so you can see it again. And just to refresh your memory on that, if I say, python3 mortgage.py, it came up and printed a number, $824,000. One of the things that you might want to do with this program is extend it to produce a little bit more output. I want to talk about the print statement a little bit here. So, let's say you wanted to extend this program to print a table of some kind. Like, maybe I'm gonna print out the month, like maybe a schedule for a mortgage. Maybe the month, the amount of interest paid, the amount of remaining principal, for instance. Maybe I have total payment minus the interest, and then the amount of principal. So let's say you wanted to print out a table, so I use the print statement like that. What's gonna happen in this modified version of code is that it will run, and I'll get a lot of output showing me different things. I mean, essentially, the first column of that is the month, and then the amount of interest that is being paid, and the principal that's being paid, and how much is left. The problems is, is that output just looks terrible. I mean, I don't really want to read that. It's 15 digits being printed out, it doesn't align nicely or anything like that. So one of the things that we might want to do is just format the output a little bit. So we're gonna talk briefly about how to do formatted printing because we may use that in other lessons in the future. So let's say you had some variables. I don't know, like name is IBM, shares is 100, price is 32.2 or something, and you wanted to format that. Okay, first of all, the print statement, if you don't do anything, will just print those values with a space between it. If you want to change that, there are a couple of ways to do it. One of the ways that you can do it is you can use, it's essentially the percent operation with strings. What you do is you write a little format string that looks like that, and then you say percent and you supply the values. What's going to happen here are these variables are going to get plugged into these percent codes and formatted. The actual meaning of these codes, by the way, s is a string, 10 is referring to the width that's going to be printed, and there are different modifiers like this different code at the end is saying, print a number in 10 characters wide, but with two decimal places. So that's one way to format. A little bit more modern approach is you might see somebody using the format operator. This is going to look quite a bit different, but it's accomplishing the same thing. What I'm doing here is asking Python to format some values and print them out in sort of the same way. What's happening here is each little part in curly braces is getting filled in with one of the arguments to this format method, so name is going into the first one, shares is going into the second one, and so forth. And then again, the code is sort of defining what the formatting is. That greater than, by the way, that means put everything on the right, so right justify. If I were to flip that to a less than, you would find all the values aligning up on the left. There's a couple of different ways of formatting things and that is the kind of thing that I might do in this program. Like, if I wanted to have nicely formatted output, I could change this print statement to use something like that. Like, maybe I'm gonna have a five digit month, maybe the interest will be 10 digits with two decimal points, and then I'll do that same thing for the other values as well. Maybe what I'm doing here is trying to more nicely format the output, just enclose those values there. If I do that and run the program again, you'll find that it makes a much nicer table to look at. Okay, so now everything is nicely lined up, it's very column oriented, much easier on the eyes. If I wanted to put a header on the file, I might do something similar up here. Let's do format here, so we're gonna format some strings. What I'm gonna do is specify the headers of this thing, so the headers are the month, and then we have the interest, and then we have the principal amount, and then the remaining. Let's go ahead and run that and we should get a nice table now showing up. If I scroll up enough, you should be able to find some headers on that. This is the kind of thing that you would do if you wanted to have much nicer output showing up. Kind of another extension to that is you might actually want to modify the program to write that to a file. So I thought I would also mention it briefly, how to do that. If you wanted to take that output and redirect it to a file, you can use the open command to open up a file. So you give it a file name, you tell it you want to open it for writing. Okay, so this is open a file for writing. And then, what I can do in my print statements, tell Python that I want that output to go to that file. So I'm gonna add this little extension, file=out, there. And if I modify the code to do that, file is equal to out, you'll find that it produces that in a file instead. One thing we have to do when we work with files, you have to close them as well. So, when you're done with the file, you'd close it. So let's go ahead and run that. Now we don't see any output showing up here, but it did make a file called schedule.txt that looks like that. This is the kind of thing that you would do in a script to produce much nicer output. If you need to write output to a file, this is also the technique for doing that. We'll say more about files in later lessons, but this should be enough to get started for a simple program.

Lesson 3

- To do almost anything useful, you need to be able to read data into your program. In this lesson, we look at the problem of reading data from a file, basic techniques for manipulating text strings, converting input data, and performing calculations. I also introduce the CSV Module for reading data from a CSV file.

- Alright, let's talk about the basics of file IO and test strings. Suppose you have file, and you wanna read this into a Python program. Just as an example, I have a file, here Data/portfolio.csv, has some data in it. Let's say, I wanna get that into a Python program. How do I go about doing that? Well some basics to do that, first of all, if you wanna open up a file, there's a built-in function Open, that is used to do that. So what you can do is you can say, I wanna open Portfolio.csv, and you give it a mode, like R for reading, W for writing. So what I'm doing here, is telling Python I wanna open a file for reading. Once you've opened up a file, you get a file object, that you can work with, and there are a couple of different ways of working with that. If a do a read operation like that, it will grab the entire file, all at once, and up it into a text string for me. You would see the contents of the file in that string. For it to print it out, it would look more like the original file. Another way that you can work with file, is you open up the file. Again, open up for reading, and then you do a for-loop on it and this will cause the file to be read line-by-line. So what's going to happen here, is I will go one line at a time over the contents of the file, and you'll see it kind of print out like that. Essentially, the line is like one row of data in the file. So you have these two different ways of working with files that are quite common. Open it up, you can just read the whole file, or you open it and you go line-by-line. We're gonna start with that. One thing that you will notice with files is that there is this pattern, where I have to open the file, like you do the open step, and then I do some kind of operation involving reading, and then I have to do this close at the end. That closing step is actually essential for the operating system. I mean essentially, you're telling it that you're no longer using the file, and it also turns out, that, that's a step that's easy to forget or to mess up. Because of that, there's one other way of working with files that is quite common, which is to make use of the with statement. So you might see somebody writing statement like with open some file as F, and then you read the file, the same way you did before. It turns out that, that with statement, establishes, sort of a context, where you're going to use the file, and it will automatically take care of closing the file when you're done. So that is actually, the more kind of modern way that you would work with files in Python, so I'm gonna continue to use that. Now, once you've gotten some data from a file, let's talk about working with it a little bit. Let's say you had a line of data, that you've got out of a file, one of the things that you're going to start doing, is maybe some text manipulation to either clean up this data, extract items from the data, convert things, and so forth, and in order to do that, I have to say a little bit about working with text strings. First thing, if you wanna define text in Python, you typically enclose it in quotes. If you're just writing a program and you wanna have some text, you enclose text in quotes, or you enclose it in double quotes, either one of those are fine, and then to manipulate text, one of the ways that you can do it, is to treat it like an array of characters. It turns out if you start indexing into a string, you will pull out individual letters, so like A, O, gives me H and A1 gives me E. You can use negative indexes to go from the end of a string backwards, so negative one, gives me the last letter, negative two, gives me the second to last. You can also do somethings like slicing of the data. It turns out if you put in a range of indices, like that, you'll get a range of characters. You can leave off some of the indexes if you want, like eight colon five, will give you the first five letter. A negative five colon will give you the last five letter. So these are different things that I might start to do with this line of text here. I can try to slice that up to get different information out of it. Some other things about text, that I'll just mention as well, Len will give you the length of a text string. So if I wanted to calculate the length of something, that will do that. You can also join strings together with things like the plus operator. So if I had C is equal to Hello and D is equal to World, C plus D would concatenate those string. Now some other things that come up with text, let's talk about cleaning up this line a little bit. One of the things that happens with files, is you might wanna get rid of the extra characters, like this line actually has like a new line on the end of it. Maybe you wanna get rid of that. It turns out that there's an operation Strip that I can use to do that. What strip does, is it gets rid of white space, so if you're text has white space on the beginning or end, it will sort of clean that up. This also brings up an important point, that if you do anything to a string, you have to save the result. It turns out that all operations concerning strings never modify the original string. Like that stripping operation, did not change Line. If I actually want to save the result, I maybe need to put it back into a variable, so that gives me the Line stripped up. Some other things that you can do, you can do things like string replacement, like if I wanted to replace the quote with a, you know, different character, like dash, that would do that. Some other things that you can do, is you can take, like a line and split it on a character of my choosing. So right there, I'm saying, take the line and split it into parts. What's happening here, is you now get a list that has like the different parts of that line that were separated by a comma. I could then address those, using indexes there, like that. I could take that and further do things to clean up the line. Example, like this parts zero, if I wanted to get rid of the double quotes, I could ask Python to strip those away. Strip the double quotes off. It helps if you type the variable correctly there, so, there I've cleaned up part of it. You can do the same thing for Parts One. Again, I'm doing some steps to kind of clean up the data. I might do other things to clean up the data as well. You know, I have some numbers in here, like Parts Two and Parts Three. If I wanted to do any kind of mathematical calculation with those, I can't do it, at least not to start with anyway, you know, like if I tried to do multiplication, Python will complain about that, saying, you can't multiply strings. I could do things like convert though. I could take Parts Two is equal to Int Parts Two. I could convert the other one to a float. Again, what I'm doing is taking something that started off as input text, kind of split it up, doing different steps to sanitize it, different conversions with strings and so forth. These are some basic tools that you will use if you start working with files. When you start writing larger programs, you'll start using these in combination with some other things that we'll look at next.

- In this part, we're going to look at reading a file and performing a mathematical calculation on the data in that file. To start this section off, there's a file that we looked at in the last part. It was a .csv file that had four columns of data that looks like this down at the bottom. So we have the name of a stock, a date, shares, and price. What we're going to do here is I'm going to write a program, call it port.py, and what we're going to do in this program is essentially try to read that file and do a calculation with it. To start this off, let's just start with reading the file first. In order to read a file, we do the open function, so we say, "open portfolio.csv." Then what we're going to do is do a for loop on it. Like we might say, "for line in f," and let's just print the line to start. This is what we're going to start with. This is a program that will read the file, go line-by-line as it as is. That's not enough to really do anything interesting. Yes, it reads the file and then prints something out, but we actually haven't done enough to do any kind of calculation with it. What I'm going to do is extend this to do a few more operations. First of all, I am going to fix the code to use the with statement. This is kind of a better way of working with files. Just to refresh your memory on that, it opens a file and then automatically closes it when you're done. I'm going to recast the program a little bit. What I'm going to do here are some operations to sanitize some of the data. Part of what I'm going to do is strip white space off. So we'll strip the white space. What I'm going to do is split the line on the comma character, so we're going to split into parts. Let's go ahead and print the parts out. We're going to build this up in pieces here. What's going to happen now is we're going to go line-by-line, we're going to clean up white space, split it into pieces. So now what's happening is you're seeing the file being split up into these lists that are being created. What I'm going to do next is maybe sanitize some of that data. You'll notice that in the data some of the fields have things like double quotes added around it. That's something that I might want to get rid of. So maybe parts[0] I'm going to strip double quotes off. Then in parts[1] I'll strip double quotes off as well. Maybe I even convert some of the other fields as well, like I'll convert parts[2] to an int, parts[3] into a float. Essentially what we're doing is sanitizing the data in some way. Let's go ahead and try that and see if it works. Oh, it fails. This actually brings up a point about files. Sometimes you encounter data that doesn't fit in with what you're trying to do. The reason that this is failing is that Python is trying to convert one of the column headers into an integer. Specifically, this line that I've got highlighted here is not going to work on the first line of the file if the first line of the file doesn't have a number there. I can fix that, by the way. The way that I'm going to fix that is I'm going to use the next operation to skip a line. I haven't talked about it before, but what's going to happen here is this is going to skip line of input, and then when I do the for loop it will continue on with the line after that. Let's make that change. Now what's happening is you're reading the file. Each line has been split up. What you're getting is a list of the different parts of that line. You'll notice that in the parts here it's actually been converted into an integer and a float. Now to take this one step further, I mentioned that we want to do some kind of calculation with this, maybe what I want to do is calculate the total shares times price of this stock portfolio. To do that, maybe I'll introduce a variable total up here, and then instead of printing I'll update the total. So I'll say the total is equal to parts[2] times parts[3], and then print a summary down at the bottom. The total cost of this thing is equal to total. So now what you have is you have a program. It opens up a file, skips the first line, does a little bit of cleaning up of the text, sanitizing the text, and performs some kind of mathematical calculation, printing out the result. Believe it or not, this is actually a template that you could follow for reading all sorts of files. If you need to write a Python program that performs a calculation on data, you will follow this same programming model. Open a file, go line-by-line, clean it up, maybe convert some values, and then perform some math on it.

- In the last part, we wrote a program that opened up a data file, performed a calculation on that file. The parts of that program, fairly straight forward. As far as you know, we go line by line. We are doing cleaning up of the data. Doing some conversions and so forth, however there are some things that can go wrong with this program as well. One of the things that can go wrong is that somebody might provide a slightly different file to this program. I'm gonna change the code to use a different file here. Portfolio2.csv. We are gonna run it and the whole program is going to blow up, essentially, in my face. What's gonna happen is it's going to crash. Well, the reason it's not working is that somebody encoded the data in a more evil form. This is what this new file looks like down below. You will notice that it still has a name, a date, shares and a price, but the date has been encoded in a slightly different way. One of the ways it has been encoded is that it includes a comma, as part of the data. You can ask, well how does that make the program blow up? The way it makes the program blow up, it makes this splitting operation fail. It gets completely confused. There's a comma as part of the data and it shouldn't be splitting on that data. So, one of the things that you might ask is actually like a higher level question. Why am I having to clean up all of this data? Like why do I even need to do this? Split into commas and removing quotes and so forth. Hasn't somebody already solved this problem in the Python world? It seems fairly low level. The answer to that question is that these problems actually have been solved. If you are reading data and you are working with any kind of standard file encoding or anything like that, chances are that there is some library module that can help you out. One of the libraries that Python provides is a library called CSV. The whole purpose of this library is to read commas separated value file. Here's a little bit about how it works. What you can do is you open up a file, like Portfolio.csv for reading and then what you do is you apply a CSV reader to it. You say csv.reader(f) and what will happen when you do that is it will automatically take care of splitting all of the rows apart and eliminating quotes and doing other things. So, like if I would do a (mumble), you will find that it is already doing a lot of the clean-up stuff. You know, it is properly splitting things, it's removing double quotes. You will find that it also works with this other data file, where it had the, you know, like a comma, as part of the data. So, if I was to put a CSV reader around that and doing the same experiment you will find that it properly captures the date, even though there's a comma as part of the date there. So, if you are working with file reading, for real, you really should be on a lookout for standard library modules to help you out. Turns out that this import module would be improved by using that CSV module. What I can do is import that and then instead of working with the file, at such a low level, I can put a reader around it, csv.reader, and then use that in place of raw line. I'm still gonna have to skip the headers. Okay, skip the header row, but then I can rewrite this for (mumble) to be much higher level. I don't have to worry about stripping white spaces anymore. I don't have to worry about commas splitting anymore. I don't even have to worry about removing quotes anymore. I can take a lot of this code and simplify it. I do have to worry about type conversation, as part of converting things and to ends and floats. Maybe that is something that I would still need to do, especially if I'm going to do math calculations. I would still have to worry about that part, but essentially with that CSV module I can, you know, greatly simply the code and it's actually dealing with a lot of the low level details for me. So, here is kinda of modified version of that code, should work with either one of those files. Oh, I haven't imported that file, okay. So, I run that, it should work fine. If I work with the other data file, it should work fine as well. So, I think if there's any take away on that, be on the lookout for any standard library modules, especially, if you are dealing with common file encodes. It can really help you out and it will greatly simplify your code.

Lesson 4

- As you write larger programs you'll want to get organized. The primary way of doing this in Python is to write functions, and if you write functions, you'll want them to play nicely with others. In this lesson, we look at the problem of writing function definitions, handling exceptions, and coding practices that will help you when you start to write larger programs.

- Let's talk about the basics of Python function definitions for a minute. If you want to write a new function in Python, the way that you do that is with the def statement. So you might make a function, like def greeting, takes in a name, and then prints out a message like "Hello" name. This will give you a function that you can use over and over again in your program. So you can say greeting ("Guido") and it would say, Hello Guido. Or you could say greeting ("Paula") and it would say Hello Paula. If you want to write a function that returns a result, you do the same sort of thing. Like maybe I have an add function that carries out some calculation. If I want to return a result back, you use the return statement. So this will give you a function that carries out some calculation, but it gives you the option of saving the calculation. So I could a is equal to add (4,5) and then a would get nine. A few critical details about functions. First of all, if you write a function, any variable that gets created in that function, including the arguments or result, is entirely private to that function. So if I'm sitting outside, there are no variables, x and y defined right now. Essentially, everything that happens in a function, stays inside the function. Python behaves like other programming languages in that respect. Another thing about functions that I'll mention, there are a couple of different ways of calling a function. So here, what I've done is I've called add, and I've provided just the inputs in the order listed, like four is going to be the x, five is going to be the y. If you happen to know the names of the arguments, you can also name them. So I could say things like add, x is 10, y is 15, and that will do the same thing. 'Cause it's known as keyword argument passing, by the way. One of the things that you can do if you name the arguments is switch the order up. And you don't really have to worry about screwing it up if you specify the arguments in the wrong way. Python will give you an error. For instance, if I were to add with five and then later say x is 10, for instance, I would get an error saying, what are you doing. You gave me two different values for x. So a couple of different ways of calling a function. And then a final things with functions that I'll mention, it is quite common for a function to include a string as the first argument. You'll sometimes see somebody define a string that has some descriptive comment of some kind, like Issues a greeting, for instance. What that is, is that's something known as a documentation string, and it feeds Python's help command. So if you perform a help on that function, you'll see that string that you defined there. So these are some of the basics of getting started with functions. The next section, we're going to use functions to improve some of the data processing code that we wrote earlier.

- The last section, we wrote a function that read a file, performed a calculation, and then we started using that function. What I'm gonna do next is talk about one of the most annoying problems of working with functions and working with data. And that problem is how to handle errors. Just to illustrate that, right now we have this function, and we have this code. It's reading a data file and performing a calculation. One of the things that's going to happen is invariably, somebody is going to execute this code on a file that has bad data in it. Let's say I change the file name to something called missing.csv. I'll show you that in a second. And I run the program. What's going to happen is the program is going to fail. And the reason that it's failing is it's trying to perform a calculation on data that it's not expecting. In this case, what's going on, is that this missing.csv file contains data, but in some of the rows there were actually missing columns, like a missing data value. There's one that's missing. He's one that's encoded at N/A down below. That is going to cause the program to blow up. You see it blowing up because it's generating an exception when it tries to do integer conversion. So, what I wanna talk about first is actually how to catch that error if there's a possibility that the program can blow up, and you want to deal with it. So, you've decided that I wanna ignore that or I wanna catch it, the way that you do it is you enclose a block of statements with a try block. So, I'm gonna use a try statement, and then I'm gonna use the except to try and catch a very specific error. Now, what's happening here is I'm looking at how the program is failing. Down here, it's failing with a ValueError. What I'm doing with the except is I'm telling this program that I want to catch that error, saying I want to catch a ValueError. And so, I'm gonna catch that. And then, what you can do in the except block is provide maybe some kind of diagnostic for instance. What I'm gonna do here is maybe print out a message saying hey, you got a bad row, and I'll print it out. The other thing that I'm gonna do here is I'm going to make the code skip the rest of the calculation. One thing that's a little bit tricky with catching exceptions is I don't really want this statement afterwards to run if there has been an error. I mean it wouldn't make sense for that to run. So, I have a couple of ways to deal with that. One way to deal with it is I could put a continue statement in here. This is something that skips to the next line. It would skip to the next item in the row there. I could do that. Another way that I could handle that is I could move the calculation into the try block. That would be another option. I think I'm gonna stick with the first option, since we were kind of rolling with that. So, what I'm doing here is trying the calculation. If it fails, I'll print out a warning, and then just keep on going. So, let's try that and see if it works. So, let's save the program and see what happens. Now the program is running, and you see it reporting information, you know Bad row, and then it carries on and gives me the calculation. At this point, it actually brings up another question though. Why is this row bad? This is actually one of the tricky problems with error handling, is that you get an error, you want to generate a useful diagnostic to the user, and you've told them, yeah, you have a bad row, but you really haven't given them any information about why it's bad. So, to do that, one of the things that you can do with an except statement is add this extra little qualifier here, this as err, or as e or something, essentially the as key word there. What's happening here is this will store the exception in a variable, like the error will become like a variable that I can use. And if I were to print that out, it would give me more information. Like if I print out Reason error, what's going to happen is you're going to get a more useful diagnostic. So, if we run that, it will come back and say, hey, there's your bad row. And then below that, it will actually tell you the reason, invalid literal for int, empty string. So, doing things like this, usually a good idea with error handling. You know it's trying to be helpful to the user of this code, telling them, hey, you have a problem. Turns out that there's actually more that you could do with error handling. One of the problems with this code right now is it doesn't tell the user any information about where this is bad. You know, imagine that this was instead of file with seven lines in it, this was a file that had 100,000 lines of data in it. We're not really telling the user where in this file this bad row is appearing. So, one of the things that you additionally might want to do is maybe keep a row number of some kind. Like maybe you wanna keep a row number, and then, somewhere in iterating over this data, maybe you increment the row number. Something like that. And then, you will report that in the error message. Maybe you indicate a row or row number, like this. And then, the idea is that this will starting reporting the location in the file where this thing is bad. We have to look at our error message. It's telling me that I have a typo in my variable name. So, let's go ahead and fix that. The fact that I made a typo there is going to be motivation for something I'm gonna show you in about 10 seconds here. Okay, so now we have error messages telling me the row number and error message. The thing I wanna talk about next is actually a very useful thing to know about in the context of generating errors. Turns out that keeping a counter like that, when you have a for loop, this is a really clumsy way to do that. Turns out, a much better way to do this is to use a feature of Python, known as the enumerate function. What I can do is I can modify the code to use enumerate, like that. Turns out that what enumerate does is it will give you an extra counter that goes along with a loop, you know like a for loop like that, and it will just constantly update, as you go through the for loop. And it actually saves me the trouble of having to worry about updating that. Like I don't have to initialize it. I don't have to increment. The fact that I made a typo in my code, I don't really have to worry about that. You know, it sort of takes care of those details for me. So, I'm gonna use enumerate as an alternative. The start here is just indicating the start of the count. I'm saying I wanna start with row one. So, let's go ahead and run that. Now we have a function, essentially will read through data. It will catch errors in the data, and then report hopefully a useful error message back to the user, sort of saying where that took place, the reason why it failed, and so forth. So, this is something that is very commonly done in functions where you'll write code. And then, you do need to start paying attention to things like error messages and reporting things back to the user.

- So I wanna talk about some advanced aspects of designing and writing functions in Python. And to introduce that, I wanna return to this portfolio cost function that we wrote in the last section. Just to talk about it for a second, this is something where you're given a file, read through the file, performs the calculation, and it had the option for catching bad data. So if you ran a file that had bad inputs it caught those and issued warning messages. One of the things that I wanted to start with just concerns this try except statement that I had in the code. How did know that the program was going to raise a value error exception? This is a question that comes up a lot in writing code. How do you know what errors are going to generated by some piece of Python code, and the unfortunate truth is you often don't know. You don't know in advance unless you read the documentation or you read the source. In the case of this function, the reason that I'm catching value error is that I saw the program failing before with that error, and sort of after the fact I added exception handling to the program. So I kind of added it after the fact. One thing that comes up in a lot of programs is that catching errors can be a particularly tricky thing to get right. One common mistake that sometimes people make is they will do what's known as like a catch-all exception, like they might say except exception as error. This catches all errors. I sometimes heard this referred to as the diaper pattern in that catches everything. You're not gonna be able to un-forget that now that I've said that, but this is something that sometimes people will do. And I'll make a comment that this is a particularly dangerous practice. If you do that, you'll find that the code still runs. The reason it's kind of dangerous, though, is that it will catch errors that you're not expecting. Let's say somebody had this code up here and they made a typo in the code, like they said row three is equal to flot instead of float, for instance. One of the things that will happen is the code will still run, but it will start acting sort of weirdly screwy, if you will. What happens is it's complaining about bad rows, and then it's giving kind of weird error messages that's not really that good. If you're writing a function to the extent possible, you should really try to narrow exception handling, down to like be as precise as possible. So catching all errors, it's a little bit of a dangerous practice. You wanna try to avoid that to the extent possible. There it actually crashes instead of running. That's probably a good thing there. Another thing with this code just concerns these print statements, this portfolio cost. Imagine that it got integrated into like larger program. Okay, so we're starting to write a larger application. We have lots and lots of functions being strung together. These print statements are sort of weird. You call the function with bad data. It starts printing. We don't really have way to control those, like I don't have any way to control where they go. I don't have any way to silence the errors. Somebody might look at this code and they say, you know, I'm really annoyed with these print statements. It's almost like the print statements are like this side effect of the function that you have no control over. And so one of the things that might start happening is you might modify the function to have more control over what happens with errors. Maybe I give the function like a little optional argument. I would say errors is equal to warn. And then down here, I would provide an option saying well, if the errors is equal to warn, then I'll print out a warning message, otherwise don't do the warning message. What's gonna happen with that is you give the user the option of silencing the warning. Maybe they would come in here with like an argument saying well, I want the errors to be silent or something. Okay, so I've added an argument to the portfolio cost, just trying to get the function all on the screen there. What would happen there is now there's like a second argument that could either turn off or on the warning message. One practice with Python, by the way, there's this zen of Python. Part of that actually tells you that errors in Python should actually never pass silently unless explicitly silenced. That is actually something that we're kind of following here. It's like by default we're reporting warnings, but we do give the option for the user to silence them. This code that I've written, I've actually done something to it that I'm not particularly happy with, and it concerns this extra optional argument. One of the things that's a little weird about that is actually the way in which it is called in code. So I've highlighted this statement here, portfolio cost, missing CSV silent. One of the things that somebody might do is they look at that and they would say what is the silent about? Doesn't really read well to me, you know, it has like this magic argument silent. I'm not really sure what that is just looking at it in isolation. And so one of the things that you might consider doing, whenever you have optional arguments like that, keep in mind that this is an argument that is optional, might be provided or might not, is to use this key word argument passing style. I could say errors equal silent, for instance. To me, that kind of code actually reads a whole lot better. One of the things to think about in terms of writing code is you want the code to be able to be readable by others later on. If somebody were looking at this code, and they said okay you're doing portfolio cost, errors equal silent, that sort of jumps out a lot better. It just reads better. Somebody will look at that and say oh, okay, you're silencing the error messaging. So that's something that you might think about. You can also force people to do that, by the way, if you were to write the function and to put a star before that optional argument, you'll find that you have to use the keyword style. It turns out that will force somebody to use this style. If they don't use that style, then they will actually get an error. This might be something that's a little bit hard to appreciate in like a small program, but when you start writing larger programs, making it easier to kind of document functions and read functions actually becomes really important. So I actually like that keyword style, and I actually like forcing it on people in certain applications. We're still not done with this function. Okay, so we've given it, you know, an optional argument. There are some other kind of bad things about it. One of the things that's bad about it actually just concerns the fact that I use the word silent there. Why couldn't I use ignore? Turns out I could use ignore, and part of the reason for that is that the code that is checking that error's value is being extremely sloppy about how it works. What it's doing is it's just saying if it's warn, I'll print a warning message, and then it never even checks any of the other cases. And might be the case where this error's argument is actually kind of expanded out to have different values. You know, maybe there's an option that causes it to raise an exception, like this thing that I'm doing here re-raises the last exception. You know, maybe I have like another if that basically just ignores it. Maybe I have something like that. I do run into problems with sort of knowing like what are the valid values for this errors argument. As a final thing that I might wanna do on this function, is I might wanna be a little bit defensive about the input, like I might check to see whether this error is in some approved list. Like it could be warn, silent, or raise, and then if it's not in that list, I would raise an exception. Maybe telling the user that it has to be one of those. I'm gonna change this to double quotes. One of the reasons for doing double quotes is it allows me to do single quotes inside. So I might wanna, you know, modify the code to have a check on inputs. Essentially this will catch problems where people give it unexpected input. Like there it works. Actually, I screwed that up, I think. If errors is not in that, then I raise an error. Let's try that. Okay, so if I give the bad value, it will tell me that's a bad value. That's often a good practice, by the way. Being defensive in function definitions is often a good strategy to take, especially as you start to write larger programs. Okay, so we've got code where we're checking for that. And I guess that actually brings up one final thing about functions and error handling that I wanted to discuss, which is what errors are you actually supposed to handle in a program. Having taken this little defensive step here, one thing that somebody might ask is whether you should take that one step further. Let me show you an example. Let's say somebody were to call this code with just a completely bogus file name, like they say bogus CSV, and they run the program. What is going to happen is the program is going to crash. It says oh, you have a file not found. With this open call, you might ask a question is that something, should I be defensive about catching that? And my advice on that, and this might sound kind of counter-intuitive, never catch errors unless you can actually deal with the error at that point. In the case of this program, if I can't even open the file, I'm not really sure what the recovery is. There's no recovery option in this function for a bad file. I mean, what do I do, right? Just return zero? It doesn't make sense to recover from that, so in terms of writing this code, I would just not worry about cases like that. If your code is crashing with exceptions that are beyond your control, it's often better just to let the program crash. There may be some other piece of code that is programmed to catch that. Maybe there's a user interface or something that would tell the user hey, you gave me a bad file. But it's not in this function itself. So as a little summary, these are all things to kinda think about in terms of writing functions. You wanna think about some of the side effects that functions might have, you know, like reporting error messages and so forth. That might be something that you wanna silence or control. You wanna think about how arguments are passed into functions, for instance forcing people to use keywords. You wanna be defensive in your programming. You know, checking valid inputs to functions. You know, to the extent that it makes sense. And so forth. So these are all things that'll be useful as you start to write larger Python programs.

Lesson 5

- One of the most critical Python skills to develop is being able to effectively use lists, tuples, sets, and dictionaries. In this lesson, you'll see how to read a file into a useful data structure. We then explore different ways of performing calculations on the data, including data reductions, filtering, joining, and sorting. Particular attention is given to list, set, and dict comprehensions, a feature that greatly simplifies a wide variety of data processing tasks.

- We're gonna start this section with a review of Python's built in data types. These are objects that you're gonna use all the time in Python. I just wanna kind of quickly cover the basics of them. Let's just do a little demonstration here. One of the core data types that you might work with is something known as a tuple or tuple. So actually what a tuple is, is it's a bunch of values packed together into a single thing. Like what I'm doing here, is I'm making a tuple that has a name, a date, shares and price and what you will find is that the result is an object that holds all four of those values. Under the covers, it looks a little bit like an array. So it has a length to it. You could index into it to get different values. You could even perform calculations with some of the values and so forth, but the key thing is that you've taken these values and kind of packed it together. A few notable things about tuples, one mental model is they are kind of like a row in a data base or a row in a file. Think about them as a record. You have a record, it has multiple parts to it. First name, last name, street address, zip code. That's kind of the mental model on a tuple. Another notable thing about tuples, typically when you work with them, you're thinking about packing and unpacking. It turns out that this initial step of creating a tuple, what I was doing was packing values together. One of the things that I can do is unpack the values. I can do an unpacking step and I'll get all four values placed into separate variable. Tuples are also immutable. It turns out if you make one of them you can't change any of the value. Once you've created it, it's kind of fixed or frozen in space, if you will. So this is the first data type, Python's tuple object, a bunch of values packed together. Another data type that is used a lot is Python's list object. Essentiually a list is a bunch of items. Maybe I have a list of stock names or something like that. Again, it works like a little array, so you can get a length and you can index into it. But what's going on with a list is it's actually something that you can modify. For instance, you can append things on the end of a list. You could insert things in the middle. There's all sorts of things that you can do to change the data that's in a list. You can freely overwrite any of the methods or any of the items. So if I wanted to change one of the entries to something else, I could certainly do that. So this is another core data type. Give me a list of data. One thing to note about lists as opposed to tuples, is that usually with a list, all of the items are of the same type. Like you might have a list of strings or a list of numbers or something like that. It's very common when building lists that all of the items would all be of the same kind of item. That becomes more important later when you start to do data processing on it. It's kind of a notable distinction between lists and tuple. You know, here you have all the same kind of thing. When you make something like a tuple, you have one record, it has multiple parts. The different parts might actually be different kinds of data. So that's another built in data type, Python's list object. Another type that turns out to be useful is Python's set object. The way that you write out a set, I'm gonna write something called distinct names here for reasons that will become apparent in a second. You use a curly brace and then you put a bunch of items in there and one of the things about sets is that they eliminate all duplicates. If you had a collection of names like that. Notice that I've got IBM and Yahoo repeated a few times. When you make a set, all of those duplicates will just disappear. So what you're gonna get with a set is you get a collection of just distinct items or unique items and one of the main uses of a set is actually in problems related to that. Like you might want to deduplicate data or eliminate duplicates from a data set. A very easy way to do that is to take it and turn it into a set. Like if I were to say set out of names, you would see IBM kind of drop out of there once. So it's just giving me the unique names. The other thing with sets is they're very often used for sort of membership testing. Like once you have a set, you might use something like the in operator to tell you whether something is in there or not and if it is, you'll either get true or false. So sets, very useful, again for problems involving duplicate detection, membership testing, that kind of thing. The final data type I thought I would mention is Python's dictionary data type. Essentially a dictionary is a mapping where you have keys mapped to some other value. What I'm doing here is maybe making a mapping between stock names and the prices of those stocks. So I'm building up a little data structure like that. What this is going to allow me to do is to do fast look ups. I could say prices IBM and it would tell me the price of that or the price of AA, 32.2. It's a very easy way to kind of do these like look up problem. You also get some of the features of sets as well. It turns out that if you have a dictionary, the keys can only be in there once. Like if you try to reassign a new value, it will replace the value that was already there. And then you also get some of the features like the in operator for membership testing. So in some sense a dictionary is kind of like more than a set. It's like a collection of names and you have values attached to those names. Having introduced these sort of four core types, tuples, lists, sets and dictionaries, it turns out that you can solve a huge number of data analysis problems just by doing different combinations of these objects. One of the things to kind of note is that you can build data structures out of almost anything. For example, if I wanted to have a list of items that consisted of tuples, for instance, that is perfectly fine. You can make a list out of anything that you want. So if we wanted a list of tuples, that's okay. If I wanted to do more complicated dictionary. Let's say I had a prices dictionary where the key was the name of a stock, but then the item in here was like another dictionary. Maybe you had something like the current price and the high price and the low price, Python is fine with that. You look up IBM and then it will give you back a dictionary and you can do different combinations of look ups and so forth. So what we're gonna see in kind of the next part, how to utilize that to read data from a file and do more advanced calculation.

- [Voiceover] In a previous section we wrote a function portfolio cost that read a file, performed a calculation on the data in that file, and did some things like error check. Just to refresh your memories, this is what the code looked like for that. And when we ran the program, it would produce simple output. What we're gonna do here, I'm gonna change the program to read the data into a data structure and the purpose for doing that, I wanna be able to do more sophisticated calculations than just computing this total. So to do this, I'm gonna make a few small changes to this function. First thing that I'm gonna do, is I'm gonna change the function into something called read portfolio. So instead of just doing a cost, I'm gonna read the portfolio and that'll make, the change the comment, here. Okay, so we're gonna read a CSV file with name, date, shares, and price data. Now right away, we have a problem. What are we reading this thing into? How are we gonna store the data? For most problems, you probably want to use something like a list. So, what I'm gonna do, is I'm gonna read the CSV file into a list and I'm gonna return that back. The idea is that my list will mirror kinda the structure of that file. So, just to refresh your memory, the file looks like that. I'm gonna take that file and I'm gonna turn it into some list that mirrors that structure. We're gonna make a function that does that. Now in order to do that, here are the changes that I'm going to make. Instead of just calculating a total, I'm going to make a list instead. Okay, so I'm gonna make a list portfolio. Okay, this is going to be the list of records, if you will, and instead of updating this total down here, what I'm going to do is I'm going to make some record. We haven't talked about how to do that yet. What we're going to do is append that to the list. Okay, so we're going to make a record and append it and we'll return the list back. In some sense, it's almost exactly the same, it's just totaling up those two columns. It's just that, instead of summing up numbers, we're accumulating records in our list. That's what we're gonna start with. Now the second problem that we have to deal with is just what is this record that we're going to make. We need to figure out some way to kind of store the information from the file. One of the choices that we might make here, is that of making a tuple. Maybe I wanna make a tuple. It has just the contents of the row here. In some sense it looks like I've almost converted all the data. It might make more sense to just say tuple a row as opposed to me typing it out like that. Partly because I've already done some of these conversions up here, so it's almost in a form that I can work with. Okay, so I'm gonna make a row, gonna turn it into a tuple, I'll return that back. Let's just take a look at what's going to happen here. I'm gonna say portfolio is equal to read portfolio. And then I'll print that out, just to see what happens here. So I'm gonna comment out the other line. What's gonna happen, if I run this program, is I should get a list of tuples coming back. Okay, so you see the file's been converted into these row. Just to see it a little bit more interactively, if I run this so that I'm back in the interpreter, this portfolio list, if you kinda play around with it, has seven entries in there. Each entry is a tuple that stores a single row of data out of the file. So this is kinda one way to start with reading data into some kind of data structure instead of just summing up a number. We're gonna build a list, we're gonna add records to that list. Now in terms of performing calculations with this data, let's just talk about that for a second. By having all of the data, I could redo that total calculation by writing a loop like this. I could say total is equal to 0.0. And then maybe I would say for holding in portfolio total is plus equal to holding two times holding three. Given why that's shares times price there. Okay, so I can start doing calculations on the data. Maybe I go back to printing out the total cost. Write code, like that. What's happening there is it's iterating over that list of data and doing a calculation on it. So we're back to where we started, except that we're now working with a data structure. One possible complaint with the code that I've just written is actually this line here. That is not especially readable, at least I don't think it's that readable to have hard-coded indices like that. Kind of reminds me of doing taxes, which is not one of my favorite activities, like line 5 times line 6 sort of thing. So as an alternative, one of the things you might do is recast this for loop to unpack the variables. So since we have a list of tuples, one of the things we can do is say something like for name, date, shares, price in portfolio, those variables are going to line up with the different values that you have there, and then I can change the code to look like this. To my eyes, that looks a lot more readable. Should get the same answer so you get something like that, doing unpacking of tuples. There's still sort of a problem with that, though. One problem with this for loop, is that I actually have to unpack all of the values to make it work. Like, I have to unpack the name and the date in addition to the shares and the price. Maybe it's not a problem if I only have four items of data, however if this were a file where I had 50 columns for 25 columns or something like that, I would have to exactly match all 25 columns. And I don't really want to do that. Like I don't want to write a for loop where I list out 25 variable names if I'm only caring about two of them. One change that you might make to this code instead, is a change to what the record is. One of my favorite ways to represent data, instead of using tuples, is to represent data using a dictionary. One of the things that you can do is make a dictionary out of the data. Like this. Okay, so what I'm doing here is making a dictionary where I name all of the values. Name, row, date, shares, price, row three, so forth. What's gonna to happen there, let's just print out the portfolio so we can see the difference in what's going to happen. Is you'll get a list that has these dictionaries that have been built up. Essentially every value now has a name attached to it. Like you have date is that, shares is 100, price 32.2, and as dictionaries, I can write the code to refer to those specific keys. I can say for holding and portfolio total is equal to holding code shares times holding price. So we're kinda back to code we had earlier but what we're doing is referring to these specific key names when we do that. I really like that approach because it makes the code a lot more readable. I can read this, I can see what the different data is. It's also very compact with things like this for loop. I only have to have one variable there. I don't have to worry about unpacking, like, twenty different values. So this is yet another way of building data structures, maybe a list of dictionaries instead of a list of tuples. One thing that I kind of note about this last part, building something like a list of dictionaries, plays really nicely with other programming languages, by the way. Like here I have this list, one of the things that you might want to do is take that data and ship it off to some other program, maybe not even in the same programming language as Python. Maybe you want to ship it off to JavaScript or somewhere like that. One of the ways it's commonly used to do that is to use something known as JSON encoding. Turns out that a list of dictionaries works great with JSON encoding. Python provides a built-in library JSON that can be used to do this. And you can take a list of dictionaries and just dump it down into a JSON object. This is something I then could ship across like a network connection or ship it off to some other program. And then it could decode it. If I ever want to get that data back, there's also a load as function that can take raw data and turn it back into a Python data structure. So doing things like lists of dictionaries is actually often a really good choice for a lot of problems. Just because it's fairly easy to create that data structure. It's easy to work with it in terms of simple calculations. It's also easy to take that data and turn it into other things. So this is often a starting point for working with data. Think about lists, think about tuples, think about dictionaries. You can take the contents of a file, lead it into something, then you can start working with it.

- The previous section we wrote a function that read a file into a list of dictionaries. Just to refresh your memory on that, essentially what we had is we had this function read_portfolio and what you could do was give it a file name and then you would end up with a list of dictionaries as result. That list had seven entries in it and then each entry was a dictionary that looked like that. What I want to talk about here is how to do more advanced calculations on that data. To start that off, let's talk about the most important thing of all which is the for-loop. It turns out if you have a bunch of data, one of the things that you're frequently going to have to do is iterate over the data in order to do calculations. So the for-loop is the first thing that you're going to use a lot. Turns out if you do a for-loop, you'll go one item at a time over that data. So what we're seeing here, is it's printing out a list of dictionaries, and I'm just seeing the contents of the data. Now, what I'm going to do next, is talk about some different ways of working through that data in different kinds of calculations. I'm going to do that in the window down below, partly so that I can leave the data up on the window or you can look at it and then kind of piece it together with what I'm doing. The very first thing that I'm going to do is actually a repeat of that total calculation that I did. Let's say I wanted to calculate the total cost, I might do something like a for-loop where I would say, for holding in portfolio: total += holding ['shares']*holding['price']. This is something that we did before, but essentially what we're doing is iterating over the data and doing a mathematical calculation. Here's another kind of calculation that you might do. Let's say I just wanted to collect all the stock names into a list. Maybe what I would do, is I would make an empty list and I would say, for holding in portfolio: names.append(holding['name']). What I'm doing here is more of a data collection kind of thing. I've made a list, I'm iterating over the data and then I'm building up a new list that has the contents of that. I could even take that kind of a step further. Let's say I wanted to find out all of the holdings where there were more than 100 shares. Maybe I make a list more100 and I say for holding in portfolio: if holding['shares'] > 100: more100.append(holding). What's going on here is this is kind of like a filter that's taking place and I'm just collecting information about certain entries in the data. So I find two entries: CAT 150 share, MSFT 200 share. Turns out that these kind of calculations, extremely common on data, to do these sorts of things and you'll see that they all have kind of a common pattern, if you will. They all do a for-loop, and then they do something with the data, whether it's filter the data, sum up the data, collect data and so forth. Because this is so common, I actually wanted to talk about one of the absolute most useful features of Python, something known as a list comprehension. Turns out it's a shortcut that can be used to simplify a lot of these problems. For example, that total calculation that I did, I could rewrite that as a single line. I could say I want to make a sum where I say sum([holding['shares']*holding['price'] for holding in portfolio]). I do it as a one liner. You can look at that and say, "Wow. What just happened there?" What is going on here is that that statement in the square brackets is actually constructing a list, kind of behind the scenes, and then feeding it into the sum function. This is this list comprehension feature, where if I do [holding['shares']*holding['price'] for holding in portfolio] what you're going to see, is it makes a list for me, it's like making a temporary list and then that's what's going into the sum function. I can use that same thing to collect data. I could say, names = [holding['name'] for holding in portfolio] and that would do the same thing. What it's actually doing is going through the data and collecting that and returning it back. I could even do that more100 thing using the same technique, I could say, more100 = [holding for holding in portfolio if holding['shares'] > 100]. What I've done there is essentially a query on the data, it's like, go over the portfolio, give me everything that matches that criteria. You can change it up. If I only wanted the stock names, I could say, "Why don't you give me the names of the stock where there's more than 100 shares?" Then it would come back and say CAT, MSFT. If you've done anything with databases by the way, this actually reads very similar to something like a query on a database, select name from portfolio where shares is greater than 100, it's very much that idea. What I wanted to do is actually run with this idea a little bit and actually perform a useful calculation on this data. Essentially what this data file has, is it has information about a bunch of stocks that I purchased. Essentially, I purchased 100 shares of AA on June 11th 2007 at that price, and it has other entries in there. What I want to do is actually find out whether this portfolio of stocks is up or down in value, based on today's stock market. So, in order to do this I'm going to start with some of the things that I just did. One of the things that I'm going to start with is this calculation of collecting all the stock names. So, I'm going to start by getting the names. The reason I'm doing that is I just want to know what is in my portfolio? What stocks do I own? So this comes back and it tells me I own these stocks. Immediately I can look at that and I can see some warts in there. One of the warts is that I have duplicate stock names. Turns out that I bought MSFT and IBM on two different dates, I have two entries for that. One of the ways to get rid of duplicates, take list and turn it into a set. So, if I wanted to have unique names, I could make a set out of names. Keep in mind, one of the features of sets, is that you drop duplicates. It turns out that if that is what I know that I want, I can actually do it in one step. What I'm doing here is using something known as a set comprehension. What you do is you use this list comprehension syntax but you replace it with a curly brace. If you do that Python knows you're building a set. It'll give you unique items. It can be a very convenient way of de-duplicating data. So what I've got now, is I have a bunch of unique stock names. The problem that I'm going to look at next is how would I go about finding the current price of those stock names? My goal is to find out if I'm a good stock investor or not and what I would like to do is query the stock market. Say, "Hey, what are the prices of that?" To do that I'm going to do a couple of things. One of the things that I'm going to do is I'm going to make a name string by taking all of those names and joining them together. This might look a little bit funny, but this is how you make a string, where you take a bunch of parts and you've like concatenated them with a common separator. So, what I've said is the separator is a comma, and I want to join all those strings together. I'm going to get a name string there. Now, why am I doing that? The reason I'm doing that is I'm going to go back to the trusty URL request module for a moment and I'm going to make a request out onto the web to get a bunch of stock quote data. Turns out that you can get this information from sites like Yahoo. So what I'm going to do is go to the Yahoo site and essentially ask it for stock quotes on these names that I'm providing. That looks really cryptic. I had to look that up on the web, by the way, what that was. Essentially what I'm doing is making a request saying, "Hey, I want to get some stock quotes." And then I want to read the data back. Now, what's going to happen here is you're going to get some data that has some numbers in there. Okay, so 72.51/n9.27 and so forth. These are essentially the prices of the stocks that correspond to those names of the stocks. I have the names and then I have the prices. To get that data in a more usable form I'll say, pricedata = data.split() and look at the result. What I've done is I've taken this string, I've split it up into prices and now what my goal is, is I'm going to try to pair that up with the stock names that I had, and now I have some price data. How do I get those two things to kind of go together? To do that, I'm going to introduce another Python feature which is the zip function. Turns out the zip function is a really interesting way of taking two different sequences of data and then doing a pairing. I'm going to zip the unique names with price data in a little for-loop like that. I'm just going to print it out to start. Okay, so I do a for-loop. What you're going to see is a pairing. It essentially says, "Okay, CAT is 72, AA is 9.27" and so forth. That sort of pairing like that is something that I could use to build a dictionary, actually. It turns out if you use the dictionary function, and you zip two different things together, like a bunch of names and some data. What you'll get, is you get a dictionary where you can look up the different values. I can come in here and ask, "What's the price of CAT or what's the price of IBM?" It's kind of cool. It's like, "Okay, I've gone out on the web. I've fetched the data. I've actually managed to pair up the data in an interesting way." It's still not perfect and one of the things that's a little bit annoying is that the data is actually not properly converted. If you look at these prices, it's actually showing as a byte string. I don't know how to do calculations with that, or at least not in a meaningful way, like if I were to take the price of CAT and multiply it by 50, I would end up with 50 copies of a byte string. So that is not quite what I want but it turns out that there's a way to clean the data up. I'm going to say prices = {name: float(price) for name, price in zip(unique_names, pricedata) }. This is almost the same as that dictionary building thing that I had before. Turns out that this feature is something known as a dictionary comprehension. What I'm doing here is I'm telling Python, make a dictionary. The key is going to be name, the value is going to be float(price). Then I do a for-loop that kind of indicates where those things come from. All right, so now I have a dictionary that has stock prices in it. What I can do is look up a price, give it the name of a stock. Now what I want to do is tie that back to my original goal of finding out whether I'm a good stock investor or not. What I can do, is I can say, "Let's figure out the current value of this portfolio." I'll set it to zero, I'll do a for holding in portfolio. And then what I'm going to do is update that by taking the number of shares that I have and multiplying it by the current price. This is the trick, what I'm doing is I'm using the name of the stock as a lookup key in this prices dictionary. I know that that's going to work because I collected all the stock names from the portfolio. Those names that I got were the ones that I had in my portfolio. I'm going to get the name, I'm going to look up the price and this will tell me that the current value is 50,000 dollars. Turns out that that last calculation, I could also reduce that to something that's basically one line long. And say sum( [holding['shares']*prices[holding['name'] for holding in portfolio]). Okay, so back to a one line calculation. If I want to find out the change in value of my portfolio then I could do something like that. Okay, so I'm up about 6,300 dollar. I don't know whether that makes me an expert stock investor or not but at least it's not a negative. There's a lot of moving pieces of what I did here but here's the essential aspects to it. First of all, the for-loop, that's how you iterate over data, so you see that being used a lot. There are some variations on the for-loop that I used, for instance, that zip function let me iterate over two different data sets at the same time, useful to know about that. And then these operations like set comprehension, list comprehensions and so forth. There are very useful ways of collecting data, performing calculations on data, the thing I've highlighted, we got the unique stock names. Down here we're building dictionaries with one line statements. This could be an extremely useful thing to know about. In fact, in a lot of my day to day Python programming, this is the kind of thing that I'm doing a lot, reading data out of a file, reading data out of a database, transforming that data, filtering the data. These are kind of the essential tools that are used to do that.

- One of the things that you commonly have to do with data is either sort or group it so what I want to talk about briefly here is actually how to do that. In the previous section, one of the things that we were doing was working with a list of dictionaries. I'm actually showing the contents of those dictionaries up on the screen right now and we'll reference that in the example. Here's the problem that I want to pose, let's say you wanted to sort that data. The question is, what does that mean? Like if I were to come down here and say portfolio sort, keep in mind that lists have a sort method that you can apply, what does that even do? In fact, Python crashes if you try that. One of the reasons why it crashes is it just doesn't even know what you're trying to sort on. Like are you sorting on the name, sorting on shares, on the price, on date, I mean what are you doing? So, in order to sort data, there is a built-in sort method, but you often have to help it out with a little bit of assistance. The way that that works, is you need to write a little function that extracts some piece of information. Like maybe I would write a function holding_name, for instance, that takes a holding and returns some specific piece of information out of it. Here's the idea of how that's gonna work. If you had an entry in your portfolio, like portfolio(0), what you would do is you would apply holding_name to that and it would take that entry and then extract the piece of information. It would say okay, AA. If you have that, what you could do is pass it to the sort function and say, okay, sort, where the key is equal to holding_name. And if you do, what's going to happen is your portfolio will end up being sorted in that way. So if you say for holding in portfolio, print(holding), you'll see them go now in order of the stock. The thing that I'll point out is I actually have two different Python interpreters running here. It turns out that the order in which things get placed in a dictionary might differ between different runs of the Python interpreters. So if you're looking at that, wondering like why does it list price, shares, name, date, up above, and why is it going name, date, price, shares, below, it has to do with the fact that I'm running two different Pythons. Dictionaries are sort of random. It's not something that you're supposed to worry about but that's what's happening. So, this is how you would do a sort. If I wanted to sort on some other field, like the shares or something, I could say holding_shares. And then extract that piece of information and then what I would do is say portfolio.sort(key=holding_shares) and then that would give me the sort based on the number of shares. So now you see it kind of going in ascending order by shares over here on the right. So this is how you do sorting. Now, one thing that comes up with sorting is just the creation of these small little functions, you know, like writing these functions, like holding_name, a lot of programmers look at that and they say, you know, there's got to be some kind of shortcut way of doing that. Turns out that there is a shortcut and it involves something known as the lamda operator. So another way of doing a sort is you would say portfolio.sort(key= and then you might say something like lamda holding for instance, that would actually do the same thing as defining that little function. It turns out that the lambda operator in Python is a way of making a small sort of one expression function, like if I were to say a = lambda x: 10+x, that's a function that takes one input, multiplies it by ten. If I were to say b = lambda x,y: x + y, that's a function that takes two arguments and adds it together. What I'm doing here is I'm writing a function, like a little in-line function and providing that to sort. So it's a little shortcut. You see that used a lot in the context of sorting, I mean you can sort of write these little lambda functions and then it will drive the sort for you in a meaningful way. This is how you do sorting, do the sort method, maybe providing a key function using lambda like that. Turns out that that key function is actually used in a few other contexts. One of the places where you can do it is with the min and max function. So you can do things like give me the minimum of portfolio and then you can provide a key that returns a value that defines the min, like you can say give me the entry with the minimum price, for instance, and it would come back saying, well hey, that's the minimum price. I guess you should verify that, 32.2, that does look like the minimum. You can also use that with the max function. You can do that. Another thing that kind of enters the picture here, if you do have the data sorted, let's go ahead and sort it by name here. Let's just verify that the thing is sorted here. Okay, so we've got it sorted by name here. Another thing that somebody might want to do is group the data. Notice that we have more than one entry for IBM and Microsoft. Somebody might want to take the data, break it up into groups. There are library modules that can do that. For instance, the itertools module. This is part of the standard library. It actually has a group by function. So you can say for name, items in intertools.groupby and then you give it the list and then you also provide like this little key function. Okay, so what you can do is do a grouping. What's going to come back here is it will feed you kind of the common name and then it will feed you sort of a list of items that are all common with that name. What I'm gonna do is kind of iterate over that, what it'll do is it'll feed you the name and then the items in each group there. So what's happening here is you're sort of seeing it chunk up the data, saying okay, there's AA, there's CAT, there's GE, IBM, Microsoft, for those names, you're getting multiple entries. You can actually do some much more interesting calculations with this, like one of the things you could do is take the data and build dictionaries out of it, like I can say, let's make a dictionary where you have the name, and then you're gonna build a list out of items and then you're gonna pull name and items out of that groupby function. This is kind of the point where your job security might be going up slightly here. What we're doing here is building a dictionary out of this grouping data and now we have something where we can just do look-ups, like we can say, give me all the entries for IBM or give me all the entries for CAT. Kind of cool. This might not be something to spring on your coworkers, unless they've had a lot of coffee, but these sort of techniques, very commonly used for sorting, data reductions, data grouping, and so forth.

Leddon 6

- As you write larger python programs, you will want to write library functions and split your code across multiple files. To do this, you need to start working with modules and packages. So, in this lesson, we look at the problem of creating and using modules. We start by looking at how to use the import statement, and some of its gotchas, we then create a general purpose CSV Parsing function and apply it to some of our earlier code. The section concludes with a discussion of organizing larger code bases into packages.

- Let's spend a few minutes to talk about Python's import statement and the concept of a module. To do that, I'm gonna make a very simple file called simple dot py, it's not gonna be the most interesting bit of code but I'm going to use it to illustrate some concepts. In this file, I'm gonna make a variable called x, I'm gonna make a function spam that prints out the value of x and then we have another function, run which is gonna call the spam function and then down here, I'm gonna put some code that runs at the bottom. So I put it running, I'll make it call run. Not the most interesting Python code but if you were to run this code, like I say python three simple dot py, you will get output like, code says it's running, it's calling spam, x is 42. Now, what I wanna talk about next is the concept of the import statement. So let's say, you have some code that you've written and you wanna use it in some other piece of Python code. The way to load it and run it is to use import. So you might say something like import simple. What's going to happen is Python will find your code, execute it and then make all of the contents of that code available to you. So by doing that import, what happens is that module gets created and then the contents of that module or everything that was in the file, so there's a variable x, there's a function spam that x is 42, I could say simple dot run, you'll see that the functionality kind of showing up there. Now, a few really important things about what is happening with the import statement. First thing is that when I did this import simple here, Python actually found the file and it executed that file completely as a script. So it started at the top, went all the way to the bottom, ran every statement that's in there. One of the things that's special about that execution is that it actually takes place in an isolated environment. So one way to think about this file, is its own, is its own little world, if you will and everything that's in that file is sort of, contained in its, in its own little name space as its know. The way that you get to the contents is you have to prefix it with this name simple. So if I wanna get x, I have to say simple dot x, simple dot spam, simple dot run, and so forth. One of the things that's going on here is Python is trying to keep different source files isolated from each other. So if I happen to have like a, my own variable x for instance, that's a completely different x than the one that's in the simple module. So potentially, you could have the same variable name showing up across different files and it's all gonna work fine. Okay, so that's the first thing with modules, import or load code, it executes that code in an isolated world, you have to use the module to get access to the contents of that. You actually see that with other modules as well, you know, if I import math for instance, I have to say math dot cosine to get the different math functions or math dot square root. Okay, so that's one aspect of import. Another feature of import is that sometimes you will see, people using a variant of import where they might say something like from simple import run or something and what that does is it executes the entire file, exactly the same way as before. So if I do that form of import, you'll see all of the code run, you'll get exactly the same output as before but the big difference is that the only thing that I see is the run function. It's actually I get run and I don't get any other functionality, like there is no x here, there is no spam, I don't even get the name simple showing up. The only thing I get is the run that showed up there. Effectively, what is happening there is that Python is essentially importing the module and then it's copying something out of it. Think of this as like as a happy that's taking place and what I'm allowed to do is use the code. The reason that I bring this up is that there actually is a fair amount of confusion concerning this alternate form of import. Sometimes, people look at that and they think, oh, this must be more efficient, like maybe it's only loading part of a file or just that one function and the rest of it is not loaded or anything like that, not true, actually, that form of import, loads the entire file, it keeps everything in memory, it's just only exposing that, that run function to you. You can actually see that by the way, I mean when you do run, it actually works, there's actually no way that that would work unless the spam function was also sitting there somewhere. That's another facet of import. One other thing about that, by the way, is if I were to do a statement, like from simple import, say spam and x, what's gonna happen is I'm going to get the, like the spam function showing up and then I'm gonna get the x variable showing up. However, this x that I'm working with here is actually not the one that is used by this function. So let's say, I were to change x to 13 and then I would have run spam, you'll actually find that this change here, had no impact on the code above. Part of the reason for that is that global variables are basically pinned to the file where they're defined. So like in this spam function, this x that I'm looking at here, only refers to that x that's in exactly the same file. Down here in the interactive prompt, that's a different x that I've made there. If I wanna get access to the original x, I have to import simple and refer to it in there. So if I were to change the value there, then you'll see the change show up. Each file that you make is essentially an isolated environment. Okay, now, a couple of other aspects to modules that I wanna talk about, one other thing with module is that the import statement is a one time operation. If I do an import, you'll see the code run but then if I do an import again, you don't see anything happen, you don't see any output showing up like no running, no calling or anything like that. What is happening there is Python caches all of the modules that have been loaded. So if you've done an import one time, the module is loaded in cache and Python will never reload that code, where that cache is maintained by the way, is there's a variable in the sys module called modules and it's actually a Python dictionary. If you look up in the dictionary, you'll find the simple module sitting in there. That's where the module lives, if for some reason, I were to delete that out of the cache, which I'm not recommending by the way but if you were to delete it out of the cache, okay, so let's say, I were to delete it and I would have to type the actual proper delete statement, getting a lot of mistakes there. If I read it in import, then you would see it run again. That cache is sort of determines whether import runs the code, runs the code or not. A very frequent mistake that people make when working with modules interactively, is editing code and then trying to re-import it, like they might come up to the code above and then they would, like make a change, like you know, calling the new spam or something like that, they make a change to the code, they would come down here and import it and then they would run it and then they'd wonder like why am I not getting my modified message. Well, the whole reason you're not getting the modified message is that module has been cached. The only way to really get the new code would either be to quit Python or to try and reload the code somehow. That's one thing that trips people up, you know this one time kind of loading sort of thing. Another thing that can potentially trip you up with modules that I wanna mention is that the import statement itself might fail. To illustrate that, I'm actually going to make a directory here, I'll just make a directory called demo. I'm gonna go down into that directory and then I'm gonna go and try to do the import statement, so type import simple. The reason that this fails is that Python just can't find the module at this point. So when you do an import, there is a list of pass that get checked for files so in order to find your source code, what Python does is it consults this list, sys dot path, just one directory at a time looking for your source code and if you're code is not on that path, it just won't load, you'll get an import error. So one thing that may come up is you might have to alter this path, one of the things that you could do is append a directory to it like my code was actually up one level so I could come in here and append a directory, that would let me import my module because now, it's on the path. I'm not a huge fan of manually modifying the path like that so an alternative approach is to set up an environment variable and then run Python with that in place, this is more like a, like you can temporarily set up the path in an environment. And then when you do that, then it will find your code because you've add in a new directory there. Now there's one final thing that I wanna talk about with modules and it actually concerns this little fragment of code, down at the bottom that says running and run. One of the things that you've notice is when I run a module or an import a module, you see that code execute at the bottom. When using libraries, that is probably not what you want like it's actually not a great idea to have side effects like that or if somebody imports your code, it start printing things and doing things. And so one of the things that you can do is protect that code and this is a technique that is very commonly done where you put an if statement that checks the name of your module and then you check to see whether you're the main program or not so you might make a little change that looks like that. What is going to happen here is that program will work as a script. Like if somebody said Python simple dot py, it will run and you'll see the output. However, if you run Python and you use the import statement, you won't see that code run. What is actually happening there is every single module knows its own name, turns out that there's always a global variable name that is defined in Python. And if you're the main program or you're the interactive shell, your name is main. On the other hand, if you're imported, your name is set to whatever your module name is. So sometimes you'll see this used in scripts, people will protect the last part of the code with a little if statement, saying, well, we'll only run this code if we're running as the main script, otherwise, somebody might be doing an import statement and using functions that are in there. Those are some of the basics of import, I think the kind of a key takeaway, every single Python file you make is its own little world. You can use the import statement to execute the code that's in there. Again, there are two different forms of import, you know, there's kinda, the standard import and there's this from form that lets you lift specific names out of there, there's no difference between how those execute under the cover, so keep that in mind. And there are a few facets just to keep in mind, you know, it's, you know, modules are cached, so the import is a one time operation, there's a path that determines where files are found and then sometimes you'll see this trick with the main program at the end.

- In a previous section, we wrote a function to read some stock portfolio data, and then we did some examples with data manipulation and so forth. What I'm gonna do in this section, is actually a practical application of doing library modules in the import statement, and to do that I wanna focus on, really just kind of the problem that is being solved here, more generally. So what I've got, is I have this read portfolio function. It's opening a file, and it's doing like CSV reading, and it's doing some type conversion, and some other tasks, building a list of dictionaries as a result, just to refresh your memory on how this works, if I were to say import port, first of all I got some scripting statements in there we'll take care of. But what you do is, you can call that read portfolio function to get some data, and then you get a list of dictionaries back, that I can do calculations on. Here's the higher level question: Why do I have to write code like that? I mean, surely in the whole Python world, somebody must have written a function to read a CSV file, and do some type conversion on it. And if not, why not? So, what I'm gonna do, is actually tackle that problem of maybe generalizing this code, you know, like do I have to hard-wire this, can I make this more general? And to do this, I'm gonna use an interesting technique. This is going to be a little bit of exposure to some more advanced Python features, but, what I'm gonna do is, open up the file, and then I'm gonna put the CSV reader around it. These are some of the techniques that are used in the code above, so we're making a reader, and then we do some things like we get the headers out of the file, okay so here's the file headers, and then we get a row of data. I'm gonna focus on this row for a second, okay, so here's a row of data, on the file. Now the question is, what are we doing with that row? In the code above, what I'm doing is I'm applying some type conversions to some of the columns. Maybe that can be generalized. And here's a technique that I'm gonna use to generalize that. I'm gonna make a Python list, I'm gonna call types. And I'm actually just going to specify a list of type conversions in there. This is kind of an advanced idea, but the things that I'm putting in there are basically Python's built-in functions for converting things, like int['42'] makes an int, and float['4.2'] makes a float. What I've done here, is I've made a list, that has those types in there. Now what am I gonna do with that? Suppose I have a row of data, one of the things that I could do, is pair up the type conversion with a value, using the zip function, like I could say zip(types, row), let's just print like the two things together here. What I'm doing here, is you're sort of seeing a pairing, it's like, okay, str goes to AA, str goes to the date, not really sure what to do about dates, I'm just gonna leave it as a string, into goes to 100, float goes to 32.20. I could take that one step further, and maybe convert the row, like I could say, converted = [ func(val), for val in zip(types, row) ] And all of a sudden I get a row of data that has been converted, where the types had been converted. Focus on the last two columns there, it's like, they got converted from strings into an int and a float. I can take that even one step further, and do things like make a dictionary where you zip things like the column headers with the value of converted, and all of a sudden I have a dictionary of converted values. This is actually a very kind of cool thing that's going on here, and the reason that it's cool, is that I can use that as the basis for writing a more general library. Here's what I'm going to do, I'm gonna take this port code that I wrote, I'm gonna write it to a new file, I'm gonna make a file called reader.py, and the whole point of this file, is I'm gonna make a function, read_csv. We're not gonna focus on a portfolio anymore, we're just gonna read a CSV, give me a file name, along with some types, and then what I'm gonna do, is I'm gonna read a CSV with type conversion. Maybe into a list of dictionaries. I'm gonna take this code and generalize it. I'm actually gonna keep most of the code. Maybe instead of portfolio, I'll make a list of records. Okay, we're gonna come through here, get the headers, we're gonna keep everything about it, but here's the trick that we're gonna do. I'm gonna convert the row here, using that trick. I'll say row = [ func(val) for func, val in zip(types, row), like that. This is going to apply the type conversion. Keep the rest of it, and then instead of having this hard-coded record down here, where I make a dictionary, I'll use that trick using the headers, and the row. Okay, now we're gonna do records.append, and we'll return records. What I've done here... and we'll delete the rest of that file, is I took that code, that used to read a stock portfolio, and I turned it into something just way more general purpose I'm using this idea that I could pass in a list of functions, or type converters, and then apply that to data, or generally. See if this actually works. If this works, what I should be able to do is do something like import reader, and then I should be able to say portfolio = reader.read_csv, we give it a file name, and then in addition to that, I specify what the types are. So it's a string, a string, an int and a float. Well it didn't crash, so that's encouraging, let's see what the result is. Ah, I comes back with my list of dictionaries. That is awesome, it's like I took the portfolio reader, and I completely generalized it into like a more, you know a more useful function. This is something that's no longer tied to the idea of just stocks, or holdings, or anything. I can use this for lots of different problems here. So, starting with that, okay if we've generalized some code, here's how I'm going to use that, back in my original program. Now that I've got a library function, I don't wanna deal with all this stuff with this CSV module. I'm not interested in that anymore. In fact, maybe I don't want any of this code anymore, it's just, I wanna use the library that I wrote. And the way that I might do that, is I do the import statement, and then I could say, return reader.read_csv(filename, and then I could specify what the types are, and then I'll go ahead and pass along the errors, so that extra argument, if I'm gonna keep that, I guess I'll just kinda pass that along. Turns out that by doing that, I should be able to keep the code exactly the same as it was before. So if I run Python on port, still works, but I'm now using my library function. Few important things, again if I use the import statement, make sure that you use the name of the module, when you call it, so it's reader.read_csv, if you don't do that it's not gonna work. Also, I would need to make sure that this reader code is in a location where it can be found. In this case it's in the same directory. One final thing with this program, that I'm going to fix up, this code at the bottom is really something that looks kind of like a script code, it's possible that somebody might wanna use this read portfolio function, all on it's own, like if somebody said import port. Maybe they would wanna use read portfolio. In order to make that possible, I probably wanna silence this code at the bottom. So I'm gonna use that main trick to do that. So I'll say, if you're the main program, you can go ahead and run that. Otherwise, just work as a library function. So what's gonna happen there, is if somebody runs this, as their main program, you'll get the output, but if they use the import statement, like import port, now you don't see that. And it lets somebody call that function, from some other piece of code. So that's an example of taking code we wrote earlier, generalizing it into a library, using the import statement to load that library, you can sort of see how it's cleaned up a lot of the code that we wrote, and also an example of just writing a main program.

- In this part, I want to talk briefly about the problem of making a Python package. Essentially, a package is a collection of related modules. There's a few details involved with setting that up. So, in the previous part, we had two different files that I was working with. I had a file, port.py, which imported this reader module that we created, and it didn't do much, but it had a read portfolio function, and then a little calculation at the bottom. And then we had this other file, reader.py, where we wrote a general purpose read CSV function. So we've got two different files of code that we're working with, and we talked about loading that code with the import statement. Now, one of the things that comes up if you start working with larger collections of code, is just how to organize all of the code modules. As a general rule, you don't want to create a bunch of top-level modules. You don't want to create just like 100 files and then just throw them in kind of the top level and have people use that. Part of the problem is that you have to start worrying about naming collisions with other people's code. There might be third party Python modules that people want to install, like frameworks and libraries, and you don't want the names of your code to collide with that code. So, the standard way of handling this is to create something known as a package. It sometimes is like a hierarchical set of modules. So the way that you do that is, you're going to make a directory which is going to serve as kind of a container for your code. To do this, you need to pick some kind of name for your package. Preferably, it should be somewhat silly, given the Monty Python connection, so I'm going to make a packaged called portie. It sounds ridiculous enough, anyway. What I'm going to do is I'm going to move my code into that directory. So I'm going to move the port.py file in there, and I'll move the reader.py file in there. So what I've done is I've made a directory of code that has my two Python files in there, port.py and reader.py. In addition to that, I'm going to make an empty file in that directory called __init__.py. I'm going to talk more about that in a second, but what I'm doing here is I'm making an empty file that lives in that directory. Okay, so we have an __init__.py, port.py, reader.py. Once you do that, what you should be able to do is start doing import statements that have kind of hierarchy to them. I can say, import portie.reader for instance. What it did is it found that reader module inside the portie package, if you will. Everything about it is going to work the same. I mean, I can say portie.reader.read_csv and it will load data and, so, okay, missing types, let's go ahead and do the types there. You can call the code. It's now in this sort of hierarchical name space, if you will. And again, part of what I'm doing is I'm trying to isolate my program modules from other people's program modules. You know, I'm hoping that nobody else has made a package called portie. It's kind of unique to my project. This is the idea of getting started. You move your modules into a directory. You put that __init__ file in there. Now, unfortunately, we're not quite out of the woods with this. There are some technical details that come up if you start working with packages. One of the problems with a package is that you might find that certain files do not work correctly. Like one of the modules that I had was this file port, like I could say import portie.port here. If I try that, you're going to find that it fails, it comes back and says, no module named reader. Let me load that up. Here's the port file. It's complaining about this line here. Here's the problem that's happening here. Is this file part of the same package? Like, is that reader module, is it part of my code, is it part of portie, if you will, or is that somebody else's package? Like, is reader the name of something that somebody downloaded off the package index or something? Is that something else? Python doesn't really know. It's a little bit ambiguous. What Python basically does for an import like that is it assumes that that is, like, the top level. I guess kind of a top level import, if you will. A consequence of that is that this file doesn't even see that file in my package, doesn't even know that it exists. In order to make this code work, I would have to change the import. One of the things that I could do is I could include my package name, like I could say import portie.reader and use that, that would be one approach. Essentially what I'm doing is explicitly naming the package, so now if I say import portie.port, it's no longer confused about what reader is because it's assuming that top level name. I think a slightly better way to do that is to change the import to something that looks like this. I'm going to say from dot import reader, something known as a package relative import. Essentially what I'm doing here is telling Python that I want to load the reader module from the same directory or the same location that the port.py file is in. I tend to prefer the second approach. It actually is necessary in Python to do this. You have to be very explicit about where sub-modules are coming from. I will change the code to do that. One of the reasons why I like this second approach is that it doesn't hard code the name of the package in there, so if down the road I decide, wow, portie, that was a really stupid name for a package, my boss is never going to agree to that, what I can do is rename the directory to something else, and then I don't have to change any of my code. Actually, we could do that. Like, if I needed to move portie to something more like, you know, portenterprise or something, to make it more official for work, I could do that, and then the import statement would still work, partly because I don't have to hard code it into my application. That's one thing that comes up is those relative imports like that. Another thing that also comes up with package, just concerns the use of those __init__.py files. Like, I had to make this file, __init__.py, and one of the things that comes up with that is, I have to rename my file here. Okay, so you have __init__.py. What is the purpose of this, exactly? Well, one of the things that this file does is it will execute when code is loaded. So if I put a print statement in here, like loading portie or something, I hate the portenterprise name so let's go back to portie, here. Annoying management is a good idea, so let's go back to portie. When you import any part of that, like if I say import portie.port, you'll see this __init__.py file load up. One use of that file is to perform things like initialization steps of a package. Like if there's certain things that need to be set up you can do it there. Another common use of it is to load symbols from sub-modules and kind of collect them into one space. Like, somebody might do something like this, where they would say, from .port, import read_portfolio, and then from .reader, import read_csv. What you're doing here is you're kind of lifting symbols from sub-modules up a level, and one of the reasons why you might do that is you can actually simplify the user's life a little bit. What will happen is, somebody could come in here and they can just say, import portie, for instance ... Oh, actually, I didn't save this to the right directory, because of the changing the file name here. Let me save it back there. What's going to happen here if you import that, you can then use those functions without having to know what their sub-module is. I can come in here and just say, oh yeah, read portfolio. The user of this doesn't have to know that that was actually down in some separate piece of code. So this is a common use of __init__ files is to take sub-modules and maybe stitch them together, maybe glue a package together so that the user doesn't have to worry so much about how you've organized it. These are some of the details with packages. Again, make a directory. Make sure there's an __init__.py file in there. If there are cross-references between modules, you will have to fix up import statements, so like this from, dot, import reader is addressing that problem, and then you may elect to use __init__.py files to kind of stitch things together and make it a little bit nicer for the user.

Lesson 7

- Object-oriented programming is a fundamental part of the Python language. You see this whenever you use its built-in types and execute methods on the resulting instances. If you want to make your own objects, you can do so using the class statement. A class is often a convenient way to define a data structure and to attach methods that carry out operations on the data. In this section, we look at the basics of defining a new object, creating instances, and manipulating objects. We then see how the dynamic nature of Python allows you to write highly generic functions. The section concludes with a special topic on how to write classes that need to have more than one initializer method.

- In this part I'm gonna look at the basics of making a simple class definition in Python. And to start that out, I just wanted to revisit the use of dictionaries for storing data. So in previous sections, I represented data by making it a dictionary like I had holding a stack where maybe it had a name, and then a date shares, and price. And we did some code where we read this information from a file and we made lists of dictionaries and so forth. Kind of the idea is that you could access the data by using dictionary look-ups. And you could even write functions on that like I could write a cost function that would take a holding and do calculations. Holding shares times holding price for instance. Pass it in a dictionary and do calculations with that. An alternative way to approach this is to define a class definition instead of using a dictionary. And to illustrate that what I'm gonna do is I'm gonna make a file called holding.py and I'm gonna define a class in here that kind of captures the same thing I did. So if you want to make a new object in Python what you do is you use the class statement class holding, I'll explain the object in a little bit. And then what I'm gonna do is define an init function. The purpose of this init function by the way is to do setup. Essentially, what I'm doing is saving some data. And then maybe I can put a cost method on here that carries out a calculation. What I've actually done here is I've defined a simple data structure that I can use in Python. The way that this will work, I'm gonna do python -i holding here just to get that, is the class becomes a name where you can create objects. So I can say, I wanna make a holding AA, 2007-06-11, 100, 32.2. And what that's going to do is make an object for me. It'll make an instance of a holding. A few important things about what's happened here the name of a class is a function or it serves as a function that you use to make what are known as instances. So I've created an object by doing that. The arguments to this call are the inputs to this method init that I'm showing up above. So there's an init method that takes names, date, shares and price. And the purpose of the init is to save the data. What happens is this self argument is like a newly created empty object and what I'm doing is saving information on the objects. So what's going to happen is this age will actually have those attributes. It will store things like the shares and the price and the date. And then as far as the other functions that you put in a class, these are operations that just get carried out on the data. Turns out that this age will have a cost operation that I can invoke that will compute the shares times the price. One of the things about the cost, about how that works is when I do h.cost, Python looks at the age and says that's okay, what is that? It's a holding. Whatever that h is is actually passed as the self argument to the cost. So it turns out that every method that you write in Python on a class, always has this additional argument on the front. Kind of refers to the data that you're working with. This is the basics of defining a new object. You make a class, do init to set it up, you can put methods in there. I could put additional methods in here if I wanted maybe I have like a sell method for instance that sells shares. What I'm gonna do is make sure that that function has a self argument. You can take other arguments if I want to you know, carry out some kind of operation. And then that becomes something that I can use on instances as well. Again, make a holding object. Like that. Again it will have different attributes on here you have to give the right variable name it has a method cost, it has a sell method, and so forth. Believe it or not, this code will actually take you pretty far with defining Python objects. The Python object system does not actually have a lot of extra features or things that get bolted onto this. So, usually what a class is, is it's a collection of functions, and the functions actually serve as methods that you access through the dot operation. One of the things that's really important to emphasize is if you define a class, you can start carrying out calculations the same way that you would with things like dictionaries. For instance if I wanted to write like a read portfolio function that kind of mirrored what I did before I could certainly write code to do that. Maybe I'll import this CSV module, we'll make a list. I'm gonna make kind of a stripped down version of what we did before here. But we'll open up a file, put a csv.reader on it. Maybe skip the headers. Iterate over the rows and then what I could do is make a holding object. Again this is a highly stripped down version of what we did before but it's essentially the same kind of code it's just instead of making a dictionary, we're gonna make a holding. I'll append that and then return it back. This will become a function that I can use to read data. So let's try that out. So I should be able to do something like portfolio is equal to read portfolio.csv. This will give me a list of these holding objects and you can actually do all of the same kinds of calculations. Like it could say total is equal to zero point zero for h in porfolio, total plus equals h.shares times h.price. That's computing that total cost if you will. Kind of a interesting result that I got there. I know why it's interesting, I didn't convert the data correctly. I should probably write a test or something for that. You can do the same kinds of calculations. You can do things like list comprehension if you want to do calculations over the data filtering the data and so forth. Pretty much everything works the same way as it did before it's just that now you're using the dot. You're creating these holding objects, you use the dot to get access to the different attributes of those, you can call methods on the data and so forth.

- In the last part, I created a class for storing data and put some methods on the class. What I'm going to do in this part is talk a little bit about the core operations of the Python object system. To start that out, so let's say I have this Holding class, and you use it to make an instance. So we have a Holding object. It turns out that the whole Python object system basically boils down to three operations. So use the name of the class to make an instance like that. Once you have one, here are the three things that you can do. You can look up an attribute, this is the get operation. You can also set an attribute, like you can change a value, and then you can delete an attribute. It turns out that that's it. Those are the only three operations that the entire Python object system understands, are those three things. Now, a few interesting aspects to this. One thing about it is that Python does not really enforce any rules, at least not normally. So like when you've set an attribute, you can actually set attributes that don't even exist yet. Like right now, there's no attribute, time, for instance. But if I wanted to make one, just right here on the spot, 10:30 AM, Python is fine with that. It's like okay, make an attribute. So you can set new attribute. That leads to some very interesting problems, by the way. For instance, if you make a spelling mistake, like if I said h.share is equal to 87, now all of a sudden the object has shares and it has share on there. Again, there's only three things that you can do, you can get an attribute, set an attribute, delete an attribute. Does have some interesting consequences for things like spelling errors. Another thing that kind of ties into this, just concerns the way that methods work. Turns out that when you call a method, like you say h.cost, for instance, or you say h.sell(25), those operations are actually also layered on top of this get, set, delete machinery. It turns out that when you say h.cost, that is actually two completely separate things going on. There's the lookup of the cost, and then there's the function call, that's a whole separate operation. It turns out that you can actually do one without the other. Like if I were to say C is equal to h.cost, what happens is you get the method comes back, it says, hey here's the cost method of this holding object. If you were to put the parantheses on it, it would then fire afterward. You do the same thing for the sell, like if I said s is equal to h.sell, comes back saying, oh there's the sell method. Just to see that, there's the shares. If I were to say s and then add in a number there, you would see it alter the number of shares. So methods are layered on top of this get, set, delete machinery. One reason why you might care about this, by the way, is it actually can lead to some very crazy error messages. Here's one potential problem. Maybe you have all these attributes like name, shares, price, cost is a little bit special in that you have to put the parantheses on it. I absolutely guarantee that somebody's going to forget to put the parantheses on it. Where they might forget to do it is in maybe something like string formatting. Like maybe someone is printing out some data, where they're formatting strings and saying, okay print out the shares and the name and the cost. Then what happens is they get a crazy error message. Actually, I used the wrong variable names, so we're going to replace one error message with another error message here. One thing that they might do is, is do this. They would say, okay print out some values, and then they would get this cryptic error message, saying a float is required. Then you're going to spend a lot of time staring at this, wondering, huh, I wonder what's wrong with that? It might not be obvious that you're missing parantheses on the cost. So that can lead to some subtle behavior there, but the idea that methods are layered on this get, set machinery is interesting. Now another thing that ties into this, let's go back to getting attributes here. It turns out that there is another way to pull off attributes or access attributes, there's a set of functions called getattr, setattr, and deleteattr. Essentially what you can do is you can say, getattr(h, 'name') and this is the same as doing h.name. Or I can say setattr(h, 'shares', 50) for instance, and this is the same as saying h.shares is equal to 50. So it turns out that there are these functions that can be used to access attributes. Those are definitely worth knowing about, because you can use them to write extremely general purpose code. Here's an example of that. I could make a list saying, here's some output_columns, name, shares and price and then what I could is I could write code that says, for column name and output_columns, print column name equals getattrh, column name. That is actually really cool. What happens is you have a list of the output that you want. It becomes something that you can change, you could reconfigure it in different ways. In fact what I'm going to do is a little demo of that. I'm going to make a file called table.py and I'm going to write an extremely general purpose function in here. I'm going to make something called print_table where you give me a list of objects and then a list of column names. Then what I'm going to do is make a nicely formatted table, maybe showing attributes from a list of objects. And here's how I'm going to do that. Maybe I'll print a nice little header here. I'll say for column name in column names, print, we'll format it in a ten wide column here. So we'll print some headers. Then what I'm going to do is say, for obj in objects, and then we'll write another loop, we'll say for column name in column names. Again, we'll do a string formatting thing here. And I'm going to use that getattr function. I'll say why don't we just pull off some column name off of some object, unless you're going to convert it to a string here. So let's convert it to a string. The end thing there just makes it not print a new line. So what I'm doing is I've written a function where you give me some objects, I'm using things like the getattr function to pull off attributes. It turns out that this is something very general purpose that will work with a lot of different things. For example, let's read a stock portfolio in here. There's a portfolio. I can import that print table code that I just wrote, and I can say things like, print_table(portfolio) and then I pick what I want. I could say, I want the name and the shares. I screwed it up, colnames here. That's easy enough to fix here. I'm going to do something that is normally not advised, but I'm going to reload the table module here. So, let's try it again. So what we've got is, we can do print_table and I can pick the output column. That's actually really, really powerful, like I can pick the columns that I want. I can pick the order of the columns like if I want the shares to come first, I can do that. This is going to illustrate the core functions on Python objects, you make an object. There are really only three things that you can do. You can get, set, and delete attributes. There are a couple of different ways of accessing that. You can either use the dot or you can use things like the getattr function. If you use things like getattr, it actually opens up a possibility of writing extremely generic code. This print table thing that I've written, this is the kind of thing you might find in a library or a framework or something. It's like some very generic piece of code that just manipulates objects. Doesn't really care what the objects are, but does it in a very generic way.


- In this section, I want to talk about a very specific problem concerning the creation of instances. It's going to seem a little bit esoteric, but bear with me for a moment. So in the previous part, I made this Class Holding and representative data structure and the way that you made objects is you use the name of the class as a function so Holding AA and then you gave it input parameters and then you ended up creating an object from that. So you made an instance using the class name. One of the problems that comes up is that sometimes you want to make objects in a different way. Like, there might be multiple ways of creating an instance that you want. And the problem that you have to face is how do you do that in a class. It turns out that a class can only have one init function, so if you want to create things in a different way, how do you do it? And to demonstrate this, I wanted to do an example of all the dates. Python already has a library for dates, so don't use this code in your project but I'm going to use it to kind of demonstrate a concept here. So lets say you had a class date where you took in a year, month, and a day. You're storing some information here okay, so here's your date object and you can import that. I mean I can say import, you know, date and then you make a date like 2012, 12, 21 and you get the different attributes. How would you handle creating a date in a different way? Here's where I'm kind of getting that Let's say you had a string that had that date 2007, 06, 11 in it how would I make a date from that? One of the ways that you could do it, is I could take like this string and split it in to parts or something. And then I would have to make a date object where I convert the parts into answers or something like this. I'd have to do some kind of conversion to make that work. I'd also have to type that correctly, apparently. So, you get the idea that I'm going to have to do some sort of special processing to make that happen. And I might even write a function in here. I don't know, maybe I'll make a function date from string where you give me a string and then I do that calculation. Okay, and then we return a date, parts zero into parts one into parts two. Let's say you did this. You have some function that creates a date from a string. It turns out that there's all sorts of problems that kind of arise from that. Lets say I import my dateob and I say date object date from string 2007,06,11. Okay so let's say I do that. One of the things that's sort of problematic about this is that the function is in some sense detached from the class. It's related to class but it's sort of detached. It's off in its own little world that the code just doesn't feel like it hangs together very well. This is a known problem in kind of the python world that you might want to have different ways of creating objects. And you need to figure out some way to sort of do this in a sensible way. One of the ways that this is done in python is to define something known as a classmethod. This is an alternate way of solving this problem. What some people will do is they'll make a class, they'll put what's known as a class method on it, that might look something like this. I'll explain the CLS in a second, but what I'm going to do is take this code that I had before and I'm going to rewrite it like that. Now what is going to happen with this version of code, let me just run it on the data object here is that if I want to make a date from a string what I'm going to do is I'm going to use the class name as a starting point, I would say date from string. And then I would pass in the string and I would get kind of a date object from that. What I have is I have like a method that's kind of hanging off of the date class. I mean I can either make a date from like specific year, month, day. Or I can say date, from string where I create a date in a different way. So two different ways of making a date. One of the things that this solves is kind of puts that alternate construction technique on the class itself. So it's kind of bundled in a nicer way. The other thing that's kind of interesting about how this works, is this class method. What's special about that is that if you say something like date, from string what happens is this class that's to the left of the dot is actually what gets passed in as this cls argument. Turns out that cls there is kind of like a stand-in for date basically. So what's happening is date comes in, I'm doing some special processing, and then here this is kind of the same as saying date, year, month, day. In some sense what I'm doing is I'm avoiding the problem of hard coding the class name. Okay, this is kind of a different formulation of that. You'll actually see this used for other constructors as well. Like, I could have a class method on here that maybe gives me today's date. What I would do here is get like the local time on my machine. Let's import the time module. Then it might say something like well return the year, month, day from that. I think it's month and then month, day. This would also end up being another constructor. So let's try that out. So now you could make a date from like specific days. You could make a date from a string, like that. Or you could make a date from like today's date. Just make sure that actually works correctly. It's a little bit of an esoteric topic but it is something that sometimes comes up. You know, people ask, you know how do I make an object that has more than one like construction method? This is sort of the more common way of doing it as you would find with class with classmethod. Just as a final note, you might look at that and say well that's just weird. Like, why would you do class method? Or what's special about those that make it work? One of the benefits of doing it this way, actually is the fact that the name of the class is not hard coded in there. And that turns out to be useful when you start getting into more advanced uses. Like, somebody might actually make a class that inherits from date. Like you could say, class, my date, inherits from date. And then maybe start putting new methods on here I mean it's not the most interesting use of inheritance perhaps. But it turns out if you do that, this inherited class will actually get all of those alternate constructors. Like I could say d is equal my date dot today. And it will get the attributes and it will get the proper methods attached to it. So, again, a little bit special purpose. But I think it's useful to know about if you are ever faced with that problem, how to do alternate constructors. Look at class methods to do that.

Lesson 8 - Inheritance

- One of the most challenging problems in writing larger programs is that of code reuse and extensibility, and a common tool used to address this problem is inheritance. So in this lesson, we look at using inheritance to make a program extensible as well as some of the tricky practical concerns that might arise as a result. Some advanced inheritance concepts, such as multiple inheritance with mix-in classes and abstract base classes are also introduced. The lesson concludes by discussing a few important design considerations to take into account if you're going to use inheritance.

 Let's talk about some basic concepts of inheritance. To do that, I'm gonna start with the class definition that I'm showing right now. I have a class parent. This class sets up a single attribute and has a pair of methods defined on it. To see how it works, I'm gonna make a parent object. P is Parent 42. It has an attribute value. Method spam, which prints out the value. So it's Parent spam 42. And then I have a method grok, which prints out a message grok, and then it calls the spam method. So this is what I'm going to start with, is that. And so here's the big idea on inheritance. Essentially, inheritance, it's a mechanism where you can define a new class that borrows the code from an existing class in some sense. What you can do is you can define a class like Child. Now child one inherits from parent. And then what you can do is extend that parent class in some way. Just a few things before we get going. The name in parentheses, when you define a class, is actually your parent class, or what's known as a super class. So by defining a class child one from parent, it means that I'm going to take all of the code from parent and I'm gonna do something to it. In the original class, where I use object, up there, object is kind of the root of all objects in Python. Technically it's not needed in Python 3, but if you're still working in Python 2 code, it's critical to have it. So I'm including it, mainly to help anybody who might be using Python 2 out that you should still have that. So getting back to the inheritance idea, you take a class and inherit from it. Now the question that comes up is what do you do in these child classes. Well it turns out that there's a couple of things that you can do. One of the things that you can do is you can just add an entirely new method. For example, in this child class, I can add a yow method. It's just some completely independent method. What would happen is if I made a class, I still have to pass in the 42. That's coming from the parent. But what I'm gonna get is I'm gonna get all the features of the parent class. So I'm gonna get value and spam and grok and so forth. But now I'm gonna get this yow method as well. So this is one of the things that you can do with inheritance, is add something to existing code. Maybe the original class provides almost the functionality that you want, but then you want to put some extra thing on it. That's one possibility. Another possibility is that you can redefine one of the methods that's already there. Like let's say you didn't like what that spam method was doing. You just wanted to completely change it. Like it could say Child2 spam. I'm just gonna print it, the same sort of thing. But let's just say you wanted to completely redefine that. What's going to happen here is that this object that you make will again behave like the parent, but that spam method has just been completely replaced. So there if I call it, you see Child2 42. One of the things that's going to happen here as well, is if I call the other method, like this grok method, you're going to see it use the replaced method. So it prints out its message and then it uses the new version of spam. What's happening here, again you're taking a class, you're just swapping out the existing functionality for something completely different. A variant on that is the ability to wrap an existing method. So maybe what you want to do here is you could define a class that defines spam. 'Kay maybe I do like Child3 spam, but then what you want to do is you actually want to call the original version. Maybe what you're doing is you're taking this method and you're adding some little tweak to it. But you still want to use the original thing that was there. If you want to do that, you start off kind of doing the same thing you did before. 'Kay so you have Child3 inherits from parent. I've defined spam. I put in maybe any new code that I want. But then I'm gonna use a special feature involving the super function here. What this does is this invokes the original spam. I've redefined it, but that super is essentially gonna kick it off, sort of saying, "Okay, go call the version that we used in the parent." What will happen here is that if I make an object and I say spam, you'll see the child code run. But then you'll also see the parent code run. What I've done is I've made a minor enhancement to something that's there, but I'm still using the functionality that's there. If I were to say grok, you would see it, sort of saying, "Okay, there's the parent. "Oh now I get the Child3 message, "but then I'm back at the parent thing." So this is sort of the third thing that you can do, is you can inherit and kind of wrap an existing method. A fourth thing that you might do with a class or with inheritance is add a new attribute to the object. The way that you would do that is you would define a new init method, and then maybe it has an extra value coming in. What's going to happen here is you're going to change the way the object gets initialized. And I'm gonna store some kind of extra attribute. Now one of the problems in doing this is that you still have to worry about the parent. Turns out if I ignore the parent, then a whole bunch of things will break. So what you have to do here is I'm gonna use that super function to initialize the parent. If you don't do that, all sorts of horrible things happen. What's gonna happen with this class is you would make a child, but now you're have to pass in like two different values, and it will get a value attribute. No 'cause there's like extra attribute. So this is a fourth thing that you can do, take an existing class, add an attribute to it. And then kind of a final possibility with inheritance is you could potentially have more than one parent. I'm gonna make another class called Parent2 that defines a method yow here. Okay so we'll call this Parent2 yow. One of the things that you can do is make a child that inherits from more than one parent. So I could say Child5 inherits from Parent and inherits from Parent2. What is going to happen in this class is the two parents are essentially gonna merge together, and you're gonna get all of the combined defunctionality. This is what is known as multiple inheritance. So I'm gonna make a class Child5 here. I'm actually not even gonna put anything in the body of that. But what's gonna happen is you would make an instance. And you would find that you get this combined defunctionality. Like I could call the grok method, could call the spam method, and I can call the yow method. They all sort of merged together. All of these techniques, you know this idea of replacing a method, adding a method, adding an attribute, wrapping methods, having multiple parents, these are all used in practice. They all might be used in combination, or different combinations with each other. We're gonna look at a practical example in the next part.

table of contents
Settings
queue

- So, let's look at a practical example of using Inheritance. To do that, I want to look at this holding class that we did in the earlier lesson. So, we have this class holding. Basically, it represents a data structure. And, then we had a function that read a bunch of data. So, let's go ahead and get some data here. Okay, so we read a portfolio. This gave a list of these holding objects. And then, one of the things that we did after that, is I presented this print table function, that you could use to make a nicely formatted table. It was actually kind of awesome how this worked, what you could do is do print table portfolio and then you got to pick what attributes you wanted. So, you could say name price, for instance, and then you get a table with those attributes. Here's the problem that it's gonna pose, what if I wanted to make tables in different formats? Not bad, but let's say I wanted to have like an HTML table or a CSV table, or I wanted to take the data and put it in a Microsoft Excel document, or something like that. All of a sudden I have this problem of how to make code extendable. How to extend the code with new features. This is a perfect opportunity to use something like Inheritance. In order to do this, I want to look at this print table function for a minute. Let's just sort of study this function and see what is it doing exactly? One of the things that it's doing, is it has this first part of code, where it emits some table header. So, that first little printing bit is essentially emitting some table headers. And then, what it's doing is, it's doing a for loop over some objects and then it's emitting a row of table data. And, knowing that, one of the things that I could do, is I could take those ideas and maybe put them into a class. Maybe, what I'm going to do is, I'm going to make a class, called table format, and in this class, I will take those two things and put them into a method. What I'm going to do is make them raise an exception, essentially. So, I have a method for headings. And I'm going to have a method for row, that maybe takes in some row data. And again, I don't really know what these methods are going to do, but here's kind of the idea, maybe I could take that print table function and make it drive a class that has those methods. Essentially, I'm taking the alga-rhythm of making a table and I'm moving it up into a class. So, here's my thinking, I'm gonna take this print table function, and I'm gonna recast it in a slightly different form. What I'll do, is I'll make it take in a formatter as an input, and then instead of hard coding a bunch of printing, I'll drive this formatter object. Maybe I'll say, okay, formatter, I want you to make some headings out of the column name. And then down here, instead of having a bunch of hard coded printing, maybe what I would do is collect the data. I would say, okay, why don't you give me, I'm going to do this attribute thing, like, give me the attribute. Like that. And then maybe, go ahead and move that over to the formatter as well. So the idea is that I'm taking all of this printing stuff out, okay I'm getting rid of that, moving it over into a class. The idea on this, is that the print table function, you're gonna give it a formatter. Formatter needs to have headings. It needs to have row on it. Maybe I could use this table formatter class as kind of a starting point for using Inheritance, basically. What's going to happen, is this table formatter, in some sense, is serving as like a design specification. As like a design spec for making tables, what you do, is use Inheritance to customize it. Here's how that's going to work, let's say I wanted to make like, plain text table. What I could do, is make a class, text table formatter, that inherits from table formatter, and then what I will do, is implement the required method. We'll do this in a second here. So, the idea is I'm going to implement these two methods. Again, this is using this idea of Inheritance, where you can take the class and change the methods that you want. So, what I'll do, is I'll take this original output code, that I had up here, maybe I'll just cut and paste it, I'm gonna move it into a class here. So, maybe I'll say headers, for instance. I don't necessarily want it to be tied to that column name thing. We'll go ahead and format that and print. And then, maybe I'll do the same thing for this row method. The code is going to be very similar here. So maybe, item in row data, format item. So, I've taken the output code, moved it into a class, and I've modified this function that I have up here, to now work with one of these formatter objects. I'm gonna pass it an extra object, and I'm gonna drive that. Let's actually see if that works. Here's the idea on it, I have this portfolio of holding objects, I could import table. I would now make a formatter. I could say, make a text table formatter object. And then, I'm gonna hand that off to the print table. So, I would say, print table portfolio, maybe names, shares, price, and then I'm going to hand it a formatter to make the output. There, we're back to where we started with, essentially. You could pass in a formatter, use that to make different outputs. To make different outputs, this is where it gets useful, you could start making other classes that inherit from table formatter, and then do different things. For CSV, for instance, I could maybe make some output where I'm joining the headers together on comma, for instance. Same thing for the row data here. Okay, so maybe I have a different implementation of those methods for comma-separated values. I might even do something similar for maybe, an HTML table. This is probably not the real world way you would want to do an HTML table, but the idea though, is you could have a headings method, and maybe in here, you have some custom output for HTML. This is suddenly going to get really, really horrible in a hurry here, for that, but you get the idea. So, I have a custom method for that. We could probably adapt to that pretty easily for the row method here. Just changing some of the tags a little bit here. So, what we get, is we're kind of building up classes that inherit from table formatter. And then, what I can do, is use those to make different outputs, I could say formatter is equal to table, CSV table formatter. And then I could use that with my print table function. I could say, print table portfolio name, shares, with that formatter. And then we get comma-separated value. If I didn't want comma-separated values, I could change the formatter over to an HTML table formatter. And then I could do the same thing and all of a sudden I'm getting output in that format. Looks like I got a little typo in the code, but you did see it fire at least. Now, let's just make sure it actually works here, okay. We'll import table and then retry that same thing that I just did here. Now, you're getting output in HTML. This is really the big idea on a lot of Inheritance, actually, if you're using Inheritance, you really should be thinking about code reuse, or code extensibility and you can write applications that take advantage of this. Essentially, I've made a function that prints tables, that function is no longer tied to just doing things in one output. What I've done is I've moved that output code into a class, and then I've modified the function to drive that class. Where Inheritance enters the picture, is this top level table formatter, again, it kind of serves as a design spec, it's sort of defining what you need to program, to make a new table output. And then you can have different classes that inherit from that and then implement the methods as you see fit. So, that's the general idea. There actually are a number of things that could go wrong, and can be tricky about this, and we'll talk about those in the next section.

- So we're gonna talk about a few things that can go wrong with inheritance, or at least a few things that can be tricky about using inheritance in practice here. In the previous part we did an example of inheritance where I made a print_table function where you could pass in an arbitrary formatter and then use that to make outputs in different formats. The way that that worked is we had a portfolio of these holding objects and then what you could do is make a formatter object, like "formatter = table.TextTableFormatter", for instance, and then you could say, "table.print_table(portfolio" and then drive it by passing in like a formatter object. Again, a way of writing extensible code. Let me talk about a couple of things that might go wrong, or at least cause headaches. One thing that gets a little bit tricky is a situation involving attributes. Let's say this top-level table formatter class had an init method, like maybe it had an option for specifying an output file. Right now all this table is just being printed to the stdout, maybe you didn't want that, maybe you wanted to get the option to have like an output file. So maybe if the output file was equal to none we would just default it to sys.stdout. Stdout is where printing normally goes in Python, so it's a file where that gets redirected. So maybe if you don't specify where it's going we're gonna set that. And then let's say we set an attribute on the bass class. Let's say you had this, some kind of special initialization there. And let's say you had code that used that. In order to use that output file you would modify the different methods to essentially redirect to that file. I'm not gonna do this for like all of the methods, just in the interest of time, but you get the idea here. Let's say you made that modification. It turns up that you can run into some somewhat head-exploding issues if some of the child classes also wanna have an attribute. Like, let's say the TextTableFormatter, let's say you wanted to specify a width. Like, right now this thing is printing in a 10-wide column, maybe we wanted the width to be customizable, it's like a configuration then. Alright, so let's say you wanted to have a width, like that. Here's the problem: this attribute, the width, it's kind of in collision with the attribute from the base class, like, the base class needs to have this out file option. I would need to support that if I'm going to customize the init function. So one of the things that I would have to do is actually make sure that I also accept that argument from the parent class. I would at least need to account for it in some way. So, if I had a custom init I would need to deal with that. One of the things that I would also need to deal with is initialization of my parent. This is one of the problems in adding new attributes, is I would have to initialize the parent. If I don't do that all sorts of things are gonna break and then I would have to save my new width parameter. So this is one challenge that comes up, I, honestly, this thing is a very tricky thing with inheritance, is that if you have more than one init function you're gonna have to figure out some way for those to compose together or account for that in some manner. As far as using that width, by the way, this will test your esoteric knowledge of String formatting, but one of the things I can do is replace the "10" in there with another set of curly braces, and then plug in my width there. This probably falls into the category of increasing job security or something. Essentially what you can do is kind of change the width there. This is one challenge, you know, if you had that extra argument you would have to account for that. Let's just make sure that that works. I'm gonna make a formatter, TextTableFormatter, where I can specify the width is maybe equal to 25, and then I should be able to do "print_table(portfolio, "['name','shares'.'price'], formatter)". That looks like it works, but it is a little bit tricky, you know, the fact that I have my own init function on there. I have to worry about this outfile also possibly being supplied there. Here's another kind of tricky thing with inheritance: somebody might actually wanna customize the TextTableFormatter in some way. I mean, one of the big ideas with inheritance is that you can take an existing class and then customize it in some way that you want. Maybe somebody is going to do something like this, they would say, "You know, actually, "I wanna make a custom formatter "that inherits from TextTableFormatter, "and then does some kind of tweak at it". Actually, you know, instead of calling it formatter maybe I wanna do something like this, I'm gonna make something called QuotedTextTableFormatter. What I'm gonna do is redefine the row method to put quotes around everything. What I'll do is I'll take all the data, I'll say quoted is essentially equal to double quote with something, "format(d) for d in rowdata". So I'm gonna take all the data, just drop it inside double quotes, and then what I'll do is kick that up to the parent. I'll say, when I do the normal row with the quoted data. This is this idea of taking a method and wrapping it in some way. So what I could do here is I could say, "formatter = QuotedTextTableFormatter()", like that, and then I could do my print_table on it. Let's do my print_table there. What I should see is now alter the output, I mean, essentially what's happened is it's taken all the rows and it's dropping double quotes around it. Put that up there for a second. Turns up that this also presents kind of an interesting problem with inheritance. Let's focus on this code for a second. What we have is we have a method that puts quotes around the values, but it doesn't really have anything to do with TextTableFormatter specifically. Like, maybe I wanna have quotes for a CSV table, maybe I wanna have quotes for an HTML table, it seems a little weird that I've attached this to the TextTableFormatter class, it's like some kind tight-coupling basically, it's like no matter whether I like it, just totally married to that. And so what I'm gonna do is show an example of using multiple inheritance, actually. It turns up that this problem can be solved in a different way. I'm gonna make a class called QuotedMixin that just inherits from object, has no relation to TableFormatter. And I'm gonna take that row method and I'm gonna drop it in there and put exactly the same code that I had down below. So I'm gonna put quotes around that. Like that. And I'm gonna use the super function to just pass it on. So this is gonna look really odd. This is a class that has one method in it and nothing else. There's no parent, there's no other code in there, all it does is it takes a row, puts double quotes around it, and then uses the super function. Turns up that this technique, or the thing that I'm doing here, is an example of where you might consider using multiple parents or multiple inheritance in Python. One of the things that you can do if you do that is you can use it to combine with one of the other classes. So let's say I wanted quotes on like a CSV table. I can make a class, I could say I wanna make a formatter that inherits from QuotedMixin and then also inherits from the CSVTableFormatter class. What's happening here is this is taking advantage of the fact that if you have more than one parent they kind of merge together. What's going to happen is this row method that I've got here is going to merge with the row method on the other class. This might blow your mind when you see this. What I'm gonna do is make a formatter, I'll then do print_table, we'll pass in our portfolio and do "['names','shares']" with that custom formatter. And all the sudden you see the quotes on the build. It essentially combined the functionality of the quoting in the CSV. If I wanted to do HTML instead I can plug that in there as well. So let's plug it in, we'll make a formatter the same way that we did before, and then use that to print the table. Again, we get quotes on the different values. Might look at it and say, "Well, that's completely insane!" That is actually probably the big use of things like multiple inheritance in Python, and it is something that is used occasionally in libraries and frameworks, where you might have a library that provides some kind of basic set of classes, you know, like these table formatting classes, and then what it will do is provide, for lack of better word, add-ons, like little optional features that you could incorporate. One of the ways of incorporating the optional features is to do this technique that I just did with this Mixin class. It might be a class that just defines an isolated method, you know, all by itself, and then the idea is you would combine that with one of the other classes. Think Lego blocks, things like that, you're putting code together in an interesting way. So these are kind of advanced things that come up with inheritance. You know, overriding attributes, customizing classes, things like Mixins. You will see those in kind of more advanced Python code

- Writing programs that use inheritance is actually a fairly hard problem, in my experience. There is actually some aspects to designing things to think about. What I wanted to do is just briefly talk about some issues that you might consider if you're writing code that uses inheritance. To do that, I want to focus on this table printing class, and this print table function that I wrote earlier. One of the things you might think about is just the relationship between these two things. I have this print table function, which uses a formatter. I have a table formatter class, which serves as a base class. One of the things that you could ask, what is the proper relationship between those two pieces of functionality? For example, one of the things that somebody might consider is taking this print table function and making it a method on the class. Maybe the idea is you would take that function, move it into the class definition, and then maybe doing something like this. So what I want to do is have a print table method, where instead of taking a formatter, I call methods on myself. Slight change in focus here. What I've got is I have a base class in a table formatter, and I took that function above and just moved it into the class. Here's how that would work, by the way. If you decided to do that you would import table. You would make a formatter, you would say formatter is equal to table text table formatter, like that, and then you would use that to drive the printing. Then I would give it my stock portfolio I had from before, and you would produce output. This is one choice that you might make in a class, now the question is, is that a good idea or not? I think it kinda depends on the problem. In this case, I'm not really so hot on doing this. One of the things that's a little bit weird about it is that this print table method, it's actually a very special purpose actually, I mean, it's like you give me a bunch of objects and some column names, and it prints those out. I could imagine tables coming from many different places that are not that, or I could imagine generating tables in different formats that are not at all driven in that way. As a example of that, in one of the very first things that we did in the course, I wrote a mortgage calculator. You've probably long forgot about the mortgage calculator program, but one of the things that that program did is it made a table. You might remember that, I mean, I have these functions for making a table where you would run it, and you got this schedule of output that it produced. It produced something like that. Maybe I want to change that code to use my table format. I'm not gonna do that right now, but hypothetically, maybe I would change the code. That would be a little bit strange, it's like that mortgage table thing, it has nothing whatsoever to do with this print table function. So, you get asked, why is print table even here? I don't know that I like that. In terms of designing the code, maybe I want to have the functionality kind of decoupled a little bit. I don't like the idea of having a very specific implementation kinda just bolted in there like that. That's one thought. Another thought that you might consider is, maybe the table printer should be its own class altogether, like you could make a class table printer that maybe takes in a formatter. You give me a formatter, and then what I do is I move this function in as a method. So, I'm gonna take this code, kind of move it in as a method of this class. The code is starting to look very enterprise ready at this point, so what you're doing is you pulled that print table in as a method. Then, I'm gonna drive a formatter on that. So, I've got a class, you give me a formatter, then I do print table. How that is going to work is really this. What you would do is you would say import table. What you would have to do is make the formatter first, so you would make a formatter, and then you would make a printer object. Here's a table printer, and then as a argument to that you would provide the formatter, then you would say printer print table, like that. Okay, so what's happening here is you're introducing a lot of plumbing, if you will. You have connections between objects. Again, you have a printer object where you give it a formatter object, and then that is now a method on that. That works, although I'm not super happy with that code either. One thing to think about is that this class, table printer, if it only has one method, print table, maybe it's better served by just having a function. This print table code, it's a lot smaller, basically accomplishes the same thing. Maybe I would prefer to keep that around. Again, it really depends on the problem that you're solving, but as a general rule in Python, you do want to think about the plumbing between objects, and maybe trying to avoid excessive complexity. Right now this table printer class, it works, but it does feel sort of very verbose, maybe kinda unnecessary. If there were other methods that got added to that I would consider keeping it as a class, but as is, I have to admit I kinda like the print table function. Think about these things as you write larger code.

- In this part I'm going to talk about how to program a little bit more defensively in code that uses inheritance. To do that I want to talk about this table formatter class that we did in the last section a little bit more. One of the things that's going on in this table formatter is that it is serving as a kind of design specification for making tables. We have these methods, headings and row. In the base class they don't actually do anything so in table formatter they don't do anything but then what we're supposed to do is inherit from that and customize it. It turns out that there are mistakes that can be made in doing this as you start to use inheritance and write larger programs. One of the concerns is how do you enforce that programming interface. Like somebody might make a class where they inherit but then they do something like make a typo for instance. Like they say heading instead of headings. What's going to happen there is if somebody tries to use that code, like they maybe say okay let's make a text table format and then you try to use it you might find that the code just blows up later on. You'll be coding along and then all of a sudden the thing just blows up with a not implemented error. That is a little bit problematic because the error is kind of deferred all the way into the future until somebody actually tries to run stuff on the class. It might be nice to sort of catch that error a little bit earlier. So one of the features that you can do or use in Python is something known as an abstract base class. There's a library module called ABC. This is part of Python's standard library so I'm going to import something called ABC from there in a function called abstract method and what you can do is recast this table formatter so that it inherits from ABC and then it declares these headings and row methods as abstract method. Do something like that, actually once you do that I don't even need to worry about raising the error anymore I can just put a pass in. So what I'm going to do is implement some methods, declare them as abstract. The thing that's interesting about this is that this class will now enforce the existence of those methods. The way that this is going to work is that if somebody tries to make a formatter, like they say formatter is equal to text table formatter you'll actually get an error right away saying you can't do that. You didn't implement the headings method. In fact they will actually tell you what is missing about your class. This could be a very useful thing if you're every working with inheritance in a big application. Essentially this abstract base class idea can inform programmers about what is required and if they mess up you can get useful error messages back. So this is one kind of defensive strategy, if you're going to use inheritance it's often a good idea to maybe write what's known as an abstract base class to have it enforce the existence of method. Another thing that you can do to be defensive is add a little bit of type checking to some of your functions. Like this print table, one of the things that you might want to do here is do some instance checking like I can say if the formatter is not in instance of a table formatter raise maybe a type error or something. Maybe you could make a better error message. Must be a table formatter. What's going to happen here is it's just going to prevent people from passing in bad data to that function. Maybe somebody tries to pass in the wrong kind of class or something like that, that will catch that. This is actually part of the reason for structuring the code in this way by the way is that you know this base class will serve as kind of like a point where the child class is going to inherit from that. You can use the base class to do things like type check. What that type check would catch is maybe mistakes where somebody didn't inherit correctly. Let's say somebody made a class and they inherit it from object instead of table formatter. That change that we made it would catch that. So if I made a formatter from CSV table formatter and then I tried to pass that in to the print_table function, it would blow up. It would say nah you passed in the wrong kind of data. Again these are things that you tend to think about when you start writing larger programs, you know kind of controlling the environment. You know a little bit more defensive about what objects are being passed around and how they work.

- Let's talk a little about how inheritance actually works under the cover. To do that I want to start with this class parent that I'm showing you right now. So I have a class parent and one of the things that we've learned is that you can make classes that inherit on that. For example I can make a class A that inherits from parent. I have the option of redefining a method so I'm going to redefine the spam method and then there's this super function that you might see somebody using to kind of call the parent. So you can make a class that inherits from another class. What's going to happen with that is if I run that code I can say A is equal to A. If I were to say A.spam you would see it call A.spam and then you would say parent.spam. And you can continue this you know with other classes, like I could say class B inherits from A. It could redefine a method. Maybe I'll do B.spam, it could use the super function the same way if I try to use that code. Like I make a B object, what you would you do is you would see those methods kind of chain up. What's happening is we come in here we print B, we go to the parent which is a B which is A and we print that and then we work our way up the chain. How this is put together under the covers is it turns out that every class actually keeps a record of its parents if you will in an attribute called MRO, short for method resolution order. If I look at B and I look at its MRO it comes back and it says oh I'm B and then I have A as a parent and then parent is the parent of A and then you have object. What this is is this is kind of describing your chain of ancestors if you will. So whenever Python tries to fire methods it turns out that it works its way up that chain. This is the idea on simple inheritance is that every class, we're going to keep a record of who its parents are and then when you're looking at attributes it will walk this chain left to right looking for a match. This is what's going on under the cupboard. Now where things start to get interesting is if you start dealing with things like multiple inheritance. I'm going to make a class C that inherits from parent. Okay C.spam and I'm going to have it do the same thing so I'm going to have class C and I'm going to have a class D, again that implements the same functionality. Okay so we're going to have a bunch of classes that all define the spam method. What I'm going to talk about next is what happens when you start merging these classes together. So let's say you have these different classes. Like I have a class A where if you call spam you get a.spam, parent.spam. I have a class C where if you call C you get the same thing, c.spam, parent.spam. The same thing happens for this D class. You have these three classes up above, they all have the same parent, they all have a method spam on there. Here's something interesting that happens if you start combining these classes. I'm going to make a class E that inherits from A, C and D all at the same time. Okay so this is multiple inherited and I'm going to look at what happens if you call the spam method on this. So let's say you say E.spam. The amazing thing that happens here is that all of those methods will fire in a chain. You'll see it go a.spam, c.spam, d.spam, and then parent. It's like they've lined up in a row doing that. If I change the order like let's say I have a class F, it decides to do the classes in a different order. You'll find that they've lined up in that order on that object. So what's happening is you have like d.spam, c.spam, a.spam. What you're seeing here is something known as cooperative multiple inheritance. Essentially Python when it does inheritance follows two rules, and the two rules are really this. Any child class always needs to be checked before its parent. That was actually what was happening in kind of the first part of the code it was like you were seeing these chain of child working its way up through its parents. But there's a second rule that says if you have more than one parent the parents have to be checked in order meaning that you're going to check D first and then C and then A. And it turns out that with those two rules if you have more than one parent and all of those share like a common ancestor they will kind of line up in the order that you list there. It turns out that this is actually a technique that is used to do you know like composition of classes essentially. Like you could have like different classes that implement some kind of functionality that gets mixed with another class. You can essentially control the order in which these things kind of link together or compose together. It's a very kind of interesting technique to play with. It's the basis of doing things like mix in classes in Python. Just to see that under the covers by the way if you were to look at the MRO of this F you actually see those classes kind of line up one after the other where if you look at the MRO of E you see them kind of line up in the order that they were listed there. One final comment about this, the super function in Python is actually not well understood to be honest. What that super function does is it essentially moves to the next class in this MRO chain. So like if you're in this class C and you do super what happens is Python will find the location of the C class on this list and then it just moves to the next class over, so it continues on with A and then from there. Little bit of detail under the covers about inheritance works. It's got two directions essentially you go from parent to child as one of the rules but then if you have multiple parents the parents get checked in order.

LESSON 9: Magic Methods

- When defining new objects, it is usually beneficial to make your objects play nicely with other parts of Python. This is typically done by adding special, or so-called magic methods, to your class. In this section, I demonstrate some of the common customizations that are made to objects to simplify debugging, create containers, and manage resources. Although this section doesn't cover every possible customization that can be carried out, it gives you a taste of what's possible and a foundation for more exploration.

- So one of the ways that you work with Python objects is by carrying out different operators and methods on those objects. To illustrate, let's say you had a number X is 42. Some of the things that you can do with that are like mathematical calculations like X plus 10 or X times 10. Turns out that underneath the covers, those operations are actually carried out by method. Turns out the plus operator is the same as the double underscore add method. The multiply operator is the same as the mole method. It's actually true of all Python objects by the way. You know if you make a list of names for instance, IBM, Yahoo, Microsoft, or something like that. Every operation on that involves some kind of special method call. Like if I say name zero, that's the same as saying names get item zero. Or if I were to change one of the items, you know names one is equal to Facebook, that's the same as saying names set item one FB. So knowing that Python operates in this way, you know that every operation in the entire language has a dedicated method that carries that out, you can actually take advantage of this in your own classes. For example if I had a class point for instance, you know maybe this is some object that has like an X and a Y coordinate or something on there, if I wanted to, I could add some of these methods myself. Like I could add an add method that carried out the add. I'm just gonna print out what the argument is. So you can see it. So let's say you did add other. Or what happened here, is if somebody made a point and then they started using the plus operator, you would see my method fire, adding 10. Or if I said P plus hello, you would see it fire. The actual interpretation of the argument and the implementation of that is entirely up to my class. Python will merely pass in whatever data is provided and then I'm free to do whatever I want to with it. So, this is something that you'll see on classes. Essentially, classes implementing some of these magic methods or special methods to plug into Python's operators. And what we're gonna do in the next few parts is I'm gonna talk about a few of the more common customizations that you're likely to perform in real code.

So let's talk a minute about debugging. In the code that I'm showing right now, I'm showing this holding class that we defined earlier. We did a lot of examples using this class and doing calculations on it, but one of my complaints with this class is that debugging it is terrible. Like if I make a holding object and I give it some attributes, okay, so I make an object like that, there's no easy way to view it. Like if I look at it, it comes up and says, "Oh it's a holding object, it's some hexaderas." Or if I print it out, I get the same output. The same applies for more complicated data structures. If I look at this portfolio that I read earlier, I get this list of holding objects but it's not really giving me useful information. One of the customizations that you might want to make to fix this problem is to give a class what's known as a repper method or a representation method. This is a method that is used to control the string output that you're seeing below. If you don't like that output, what you can do, is you can make a string, that gives you a more accurate representation of the object. What I can do is, come in here and make, like a representation string. This little format code, that exclamation part "r" is giving me the representation of the arguments to format. I'll talk more about that in a second but let's go ahead and put a method on here. What I'm going to do is give this class a repper method, like that, just returning a string back. If I do that, you're going to find that this debugging problem all of a sudden gets a whole lot easier, I mean essentially if I make an instance and then I go to look at it, I get nice output, I can look at it and say "Oh that's A, A, and it has that date and the shares and the price." If I were to look at something like a portfolio of stocks it's way more descriptive to me. Okay, so this is a very useful thing to know about, is that you can change the string representation of an object by putting a special method on there. Turns out that there's one other method that might be defined as well, there's a method "str" and the purpose of this is to create, I guess, kind of like a nice output sting, if you will. This can actually be something different. Just to do something completely different, I'll say, so many shares of some name at some price. I'm just going to make something completely different there. This is a method that gets used by things like the print function or string conversion, just to see that in action, here's how that would work. So let's say I go ahead and make a holding object, like this, again, the same object as before. If I print it, I'll get that new output that I just made. If I look at it in the interpreter then I get the other one. Turns out that these are being controlled by two different operations. Essentially string conversion will give me the "str" method. And then there's this repper method that gives me the other one. Every single Python object plugs into these. You'll actually see this with things like dates for instance, like Python's date/time module has a date object. If you were to make a date, you'll find that if you print it you get a nice string. If you look at it in the interactive interpreter you get something sort of lower level. One thing to kind of keep in mind, this repper output is something that is meant for programmers, actually. The purpose of the first method, that's really geared at you as a developer to kind of help you out and to understand the code and so it tends to produce output that is a lot more precise and will show things like class names, arguments and so forth. Where the "str" method, that's for like output, for output. So if you care about debugging, debugging objects, consider putting these on a class. It's actually not a bad idea to think about this for almost all of the classes that you create, can really help you debug your code.

table of contents
Settings
queue



